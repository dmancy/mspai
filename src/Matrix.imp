/*
    ======================================================================
    ======================================================================
    ==                                                                  ==
    ==  MSPAI:  Modified SPAI algorithm to comupte SParse Approximate   ==
    ==          Invers matrices.                                        ==
    ==                                                                  ==
    ==  Copyright (C)  2007, 2008, 2009 by                              ==
    ==                 Matous Sedlacek <sedlacek@in.tum.de>             ==
    ==                 Chair of Scientific Computing -- Informatics V   ==
    ==                 Technische Universität München                   ==
    ==                                                                  ==
    ==  This file is part of MSPAI.                                     ==
    ==                                                                  ==
    ==  MSPAI is free software: you can redistribute it and/or          ==
    ==  modify it under the terms of the GNU Lesser General Public      ==
    ==  License as published by the Free Software Foundation, either    ==
    ==  version 3 of the License, or (at your option) any later version.==
    ==                                                                  ==
    ==  MSPAI is distributed in the hope that it will be useful,        ==
    ==  but WITHOUT ANY WARRANTY; without even the implied warranty of  ==
    ==  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ==
    ==  GNU Lesser General Public License for more details.             ==
    ==                                                                  ==
    ==  You should have received a copy of the GNU Lesser General       ==
    ==  Public License along with MSPAI.                                ==
    ==  If not, see <http://www.gnu.org/licenses/>.                     ==
    ==                                                                  ==
    ======================================================================
    ======================================================================
*/

template <class T>
Matrix<T>::Matrix(MPI_Comm world_m)
{
    world = world_m;
    MPI_Comm_size(world, &num_procs);
    MPI_Comm_rank(world, &my_id);

    my_nbr_cols = 0;
    my_start_idx = 0;
    n = 0;
    m = 0;
    all_nbr_cols = NULL;
    start_indices = NULL;
    len_all_cols = NULL;
    len_all_rows = NULL;
    remote_col_idcs_buf = NULL;
    remote_row_idcs_buf = NULL;
    remote_col_buf = NULL;
    remote_col_send = NULL;
    my_nnz = 0;
    pe = NULL;
    next_col = 0;
    max_nnz = 0;
    symmetric = false;
    block_size = 1;
    max_block_size = 0;
    block_sizes = NULL;
    I_set = NULL;
    J_set = NULL;
    A_Hat = NULL;
    A_Hat_buffer = NULL;
    mk_Hat = NULL;
    mk_Hat_buffer = NULL;
    bk_Hat = NULL;
    Tau_ptr = NULL;
    Work_qr_ptr = NULL;
    Work_qt_ptr = NULL;
    first_index_set = NULL;
    first_index_row = NULL;
    L_set = NULL;
    rhos = NULL;
    U_Nls = NULL;
    J_tilde_set = NULL;
    Aj_sq_inv_buffer = NULL;
    start_indices_Aj_sq_inv = NULL;
    residual_vals_b_buffer = NULL;
    reset_vec = NULL;
    bitvec = NULL;
    ht_M = NULL;

    hash_qr_M = NULL;
}

template <class T>
Matrix<T>::~Matrix()
{
    if (c_lines)
        delete c_lines;
    if (all_nbr_cols)
        delete[] all_nbr_cols;
    if (start_indices)
        delete[] start_indices;
    if (pe)
        delete[] pe;
    if (len_all_cols)
        delete[] len_all_cols;
    if (len_all_rows)
        delete[] len_all_rows;
    if (remote_col_buf)
        delete[] remote_col_buf;
    if (remote_col_idcs_buf)
        delete[] remote_col_idcs_buf;
    if (remote_row_idcs_buf)
        delete[] remote_row_idcs_buf;
    if (remote_col_send)
        delete[] remote_col_send;
    if (block_sizes)
        delete[] block_sizes;
    if (I_set)
        delete I_set;
    if (J_set)
        delete J_set;
    if (A_Hat)
        delete[] A_Hat;
    if (A_Hat_buffer)
        delete[] A_Hat_buffer;
    if (mk_Hat)
        delete[] mk_Hat;
    if (mk_Hat_buffer)
        delete[] mk_Hat_buffer;
    if (bk_Hat)
        delete[] bk_Hat;
    if (Tau_ptr)
        delete[] Tau_ptr;
    if (Work_qt_ptr)
        delete[] Work_qt_ptr;
    if (Work_qr_ptr)
        delete[] Work_qr_ptr;
    if (first_index_set)
        delete[] first_index_set;
    if (first_index_row)
        delete[] first_index_row;
    if (L_set)
        delete L_set;
    if (rhos)
        delete[] rhos;
    if (U_Nls)
        delete U_Nls;
    if (Aj_sq_inv_buffer)
        delete[] Aj_sq_inv_buffer;
    if (start_indices_Aj_sq_inv)
        delete[] start_indices_Aj_sq_inv;
    if (J_tilde_set)
        delete J_tilde_set;
    if (residual_vals_b_buffer)
        delete[] residual_vals_b_buffer;
    if (reset_vec)
        delete[] reset_vec;
    if (bitvec)
        delete[] bitvec;
    if (ht_M)
        delete ht_M;
    if (hash_qr_M)
        delete hash_qr_M;
}

template <class T>
int Matrix<T>::Count_NNZ()
{
    int nnz = 0, my_nnz = 0;

    for (int i = 0; i < my_nbr_cols; i++)
        my_nnz += c_lines->len_cols[i];

    // Sum all nnz values
    MPI_Allreduce(&my_nnz, &nnz, 1, MPI_INT, MPI_SUM, world);

    return nnz;
}

template <class T>
void Matrix<T>::Init_Preconditioner(Matrix<T>*& M,
                                    const int m_dim,
                                    const int n_dim,
                                    const Pattern* P,
                                    const int& maxnew,
                                    const int& nbsteps)
{
    int max_arg = 10000; // Length of buffers
    int TAU_SIZE = 1000;
    int QR_SIZE = 1000;
    int QT_SIZE = 1000;
    int bitvec_size = 0;

    double* col_buf = NULL;
    int* col_idcs_buf = NULL;

    M = new Matrix<T>(world);

    M->n = n_dim;
    M->m = n_dim;
    M->all_nbr_cols = new int[M->num_procs];
    M->start_indices = new int[M->num_procs];

    // Filling all_nbr_cols array
    MPI_Barrier(world);
    MPI_Allgather(static_cast<void*>(&my_nbr_cols), 1, MPI_INT,
                  static_cast<void*>(M->all_nbr_cols), 1, MPI_INT, world);

    // Filling start indices array
    M->start_indices[0] = 0;
    for (int i = 1; i < M->num_procs; i++)
        M->start_indices[i] = M->start_indices[i - 1] + M->all_nbr_cols[i - 1];

    M->my_nbr_cols = M->all_nbr_cols[M->my_id];
    M->my_start_idx = M->start_indices[M->my_id];
    M->c_lines = new Compressed_Lines<T>(M->my_nbr_cols, symmetric);

    // Allocate compressed lines

    for (int idx = 0; idx < M->my_nbr_cols; idx++) {
        col_buf = new T[max_block_size * max_block_size * (P->max_nnz + maxnew * nbsteps)];
        col_idcs_buf =
            new int[max_block_size * max_block_size * (P->max_nnz + maxnew * nbsteps)];
        M->c_lines->A[idx] = col_buf;
        M->c_lines->col_idcs[idx] = col_idcs_buf;
    }

    // Filling pe array
    M->pe = new int[n];
    for (int i = 0; i < n; i++)
        M->pe[i] = pe[i];
    memcpy(M->pe, pe, n * sizeof(int));

    M->block_size = block_size;
    M->max_block_size = max_block_size;
    M->block_sizes = new int[n];
    M->max_nnz = max_nnz;

    memcpy(M->block_sizes, block_sizes, n * sizeof(int));

    M->I_set = new Index_Set(max_arg);
    M->J_set = new Index_Set(max_arg);

    M->A_Hat = new T[max_arg * max_block_size * (3 + max_block_size)];
    M->A_Hat_buffer = new T[max_arg * max_block_size * (3 + max_block_size)];

    // M->mk_Hat = new T[max_arg * max_block_size * max_block_size];
    // M->mk_Hat_buffer = new T[max_arg * max_block_size * max_block_size];
    M->mk_Hat = new T[max_arg * max_block_size * max_block_size];
    M->mk_Hat_buffer = new T[max_arg * max_block_size * max_block_size];
    M->bk_Hat = new T[max_arg * max_block_size * max_block_size];
    M->residual_vals_b_buffer = new T[max_arg * max_block_size * max_block_size];

    M->Tau_ptr = new double[TAU_SIZE];
    M->Work_qr_ptr = new double[QR_SIZE];
    M->Work_qt_ptr = new double[QT_SIZE];

    M->first_index_set = new int[max_arg];
    M->first_index_row = new int[max_arg];

    M->L_set = new Index_Set(max_arg);
    M->rhos = new RHO_IDX[max_arg];
    M->U_Nls = new Index_Set(max_arg);
    M->J_tilde_set = new Index_Set(max_arg);

    bitvec_size = m <= n ? n : m;

    // reset vector must have A->m or A->n positions
    // because more positions can be stored at once.
    M->reset_vec = new unsigned int[bitvec_size];

    // Only these positions are needed within
    // the bitvec. 5: log n bits of int
    bitvec_size = (bitvec_size >> 5) + 1;
    M->bitvec = new unsigned int[bitvec_size];

    //Create new hash
    M->hash_qr_M = new Hash<T>();

}

template <class T>
Pattern* Matrix<T>::To_Pattern(Matrix<T>* mtx, const bool use_prob)
{
    MPI_Comm world = mtx->world;

    Pattern* P = NULL;

    Index_Set* i_set = NULL;

    int len, curr_len, start_idx;

    P = new Pattern(mtx->n, mtx->my_nbr_cols, world);
    P->all_nbr_cols = new int[P->num_procs];
    P->start_indices = new int[P->num_procs];
    P->pe = new int[mtx->n];

    MPI_Barrier(world);
    MPI_Allgather(static_cast<void*>(&my_nbr_cols), 1, MPI_INT,
                  static_cast<void*>(P->all_nbr_cols), 1, MPI_INT, world);

    // Filling start indices
    P->start_indices[0] = 0;
    for (int pe = 1; pe < P->num_procs; pe++)
        P->start_indices[pe] = P->start_indices[pe - 1] + P->all_nbr_cols[pe - 1];

    // filling pe array
    memset(P->pe, 0, mtx->n * sizeof(int));
    for (int pe = 0; pe < P->num_procs; pe++) {
        start_idx = P->start_indices[pe];
        for (int i = 0; i < P->all_nbr_cols[pe]; i++)
            P->pe[start_idx + i] = pe;
    }

    P->my_nbr_cols = P->all_nbr_cols[P->my_id];
    P->my_start_idx = P->start_indices[P->my_id];

    // If probing and P(A) is used, than the
    // pattern from the additional probing
    // matrices have to be omitted.
    if (use_prob) {
        for (int col = 0; col < mtx->my_nbr_cols; col++) {
            curr_len = 0;
            len = mtx->c_lines->len_cols[col];

            for (int i = 0; i < len; i++) {
                if (mtx->c_lines->col_idcs[col][i] >= mtx->n)
                    break;
                curr_len++;
            }

            i_set = new Index_Set(curr_len);
            memcpy(i_set->idcs, mtx->c_lines->col_idcs[col], curr_len * sizeof(int));
            P->j_sets[col] = i_set;
        }
    }
    else {
        // Filling pattern data structure with indices
        for (int col = 0; col < mtx->my_nbr_cols; col++) {
            len = mtx->c_lines->len_cols[col];
            i_set = new Index_Set(len);
            memcpy(i_set->idcs, mtx->c_lines->col_idcs[col], len * sizeof(int));
            P->j_sets[col] = i_set;
        }
    }

    // Get the maximum number of nnz per
    // column/row of all pes
    MPI_Barrier(world);
    MPI_Allreduce(&mtx->max_nnz, &P->max_nnz, 1, MPI_INT, MPI_MAX, world);

    return P;
}

template <class T>
Pattern* Matrix<T>::To_Pattern_Powers(Matrix<double>* mtx, const int nb_pw, const bool use_prob)
{
    MPI_Comm world = mtx->world;

    Pattern* P = NULL;

    Index_Set* i_set = NULL;

    int len, curr_len, start_idx;

    Matrix<double>* C = NULL;
    Mat* C_petsc = NULL;
    MatInfo matinfo;
    PetscInt* List_lfill = NULL;

    int sum = 0;

    List_lfill = new int[mtx->my_nbr_cols];

    for (int col = 0; col < mtx->my_nbr_cols; col++) {
        List_lfill[col] = mtx->len_all_cols[my_start_idx + col];
        sum += List_lfill[col];
    }

    mtx->Sparsify(&C, List_lfill);

    for (int k = 0; k < nb_pw; k++) {
        if (k >= 1) {
            C->Convert_Mat_to_Matrix(world, &C, C_petsc);
            C->Sparsify(&C, List_lfill);
        }

        C->Convert_Matrix_to_Mat(world, C, &C_petsc);

        MatMatMult(*C_petsc, *C_petsc, MAT_INITIAL_MATRIX, PETSC_DEFAULT, C_petsc);

        MatGetInfo(*C_petsc, MAT_GLOBAL_SUM, &matinfo);
    }
    MatGetInfo(*C_petsc, MAT_GLOBAL_SUM, &matinfo);

    C->Convert_Mat_to_Matrix(world, &C, C_petsc);

    C->Sparsify(&C, List_lfill);

    Convert_Matrix_to_Mat(world, C, &C_petsc);

    P = new Pattern(C->n, C->my_nbr_cols, world);
    P->all_nbr_cols = new int[P->num_procs];
    P->start_indices = new int[P->num_procs];
    P->pe = new int[C->n];

    MPI_Barrier(world);
    MPI_Allgather(static_cast<void*>(&my_nbr_cols), 1, MPI_INT,
                  static_cast<void*>(P->all_nbr_cols), 1, MPI_INT, world);

    // Filling start indices
    P->start_indices[0] = 0;
    for (int pe = 1; pe < P->num_procs; pe++)
        P->start_indices[pe] = P->start_indices[pe - 1] + P->all_nbr_cols[pe - 1];

    // filling pe array
    memset(P->pe, 0, C->n * sizeof(int));
    for (int pe = 0; pe < P->num_procs; pe++) {
        start_idx = P->start_indices[pe];
        for (int i = 0; i < P->all_nbr_cols[pe]; i++)
            P->pe[start_idx + i] = pe;
    }

    P->my_nbr_cols = P->all_nbr_cols[P->my_id];
    // If probing and P(A) is used, than the
    // pattern from the additional probing
    // matrices have to be omitted.
    if (use_prob) {
        for (int col = 0; col < C->my_nbr_cols; col++) {
            curr_len = 0;
            len = C->c_lines->len_cols[col];

            for (int i = 0; i < len; i++) {
                if (C->c_lines->col_idcs[col][i] >= C->n)
                    break;
                curr_len++;
            }

            i_set = new Index_Set(curr_len);
            memcpy(i_set->idcs, C->c_lines->col_idcs[col], curr_len * sizeof(int));
            P->j_sets[col] = i_set;
        }
    }
    else {
        // Filling pattern data structure with indices
        for (int col = 0; col < C->my_nbr_cols; col++) {
            len = C->c_lines->len_cols[col];
            i_set = new Index_Set(len);
            memcpy(i_set->idcs, C->c_lines->col_idcs[col], len * sizeof(int));
            P->j_sets[col] = i_set;
        }
    }

    // Get the maximum number of nnz per
    // column/row of all pes
    MPI_Barrier(world);
    MPI_Allreduce(&C->max_nnz, &P->max_nnz, 1, MPI_INT, MPI_MAX, world);

    // P->Print_Pattern_Data();
    MatDestroy(C_petsc);
    delete C;
    delete[] List_lfill;

    return P;
}

template <class T>
void Matrix<T>::Sparsify(Matrix<T>** Mat_pattern, const int* List_lfill)
{
    int rank, size;
    int i, Ii, len_row, lfill, test_idx_diag, *cols_temp = 0, col_tmp;
    int my_local_nnz = 0, max = 0;
    double val_diag = 0, *vals_temp = 0, val_tmp;
    Row_sparsify* row_sparsify = 0;
    Matrix* C = NULL;
    int *nbr_idx_del_in = NULL,
        *nbr_idx_del_out = NULL; // Number of indexes deleted per row
    int gap = 0;
    int initialization = 0;

    MPI_Comm_size(world, &size);
    MPI_Comm_rank(world, &rank);

    if (!(*Mat_pattern))
        initialization = 1;

    if (initialization) {
        /*Initialization of the sparsified matrix */
        Init_Preconditioner(C, this->n, this->n, NULL, 0, 0);

        C->c_lines->col_idcs_buf = new int[my_nnz];
        C->c_lines->col_buf = new T[my_nnz];
        C->len_all_cols = new int[n];
        C->len_all_rows = new int[n];
    }
    else {
        C = *Mat_pattern;
    }

    /*Initialisation*/

    row_sparsify = new Row_sparsify[n];
    vals_temp = new double[n];
    cols_temp = new int[n];
    nbr_idx_del_in = new int[n];
    nbr_idx_del_out = new int[n];

    memset(nbr_idx_del_in, 0, n * sizeof(int));
    memset(nbr_idx_del_out, 0, n * sizeof(int));

    // Loop over the rows to Sparsify

    for (Ii = 0; Ii < my_nbr_cols; Ii++) {
        val_diag = 0;
        lfill = List_lfill[Ii];
        //	lfill = 2;
        len_row = std::min(lfill, c_lines->len_cols[Ii]);
        len_row = std::max(lfill, 1);
        test_idx_diag = 0;

        // prepare data to keep only the largest entries
        for (i = 0; i < c_lines->len_cols[Ii]; i++) {
            row_sparsify[i].col = c_lines->col_idcs[Ii][i];
            row_sparsify[i].val = abs_complex(c_lines->A[Ii][i]);

            if (row_sparsify[i].col == Ii + C->my_start_idx)
                val_diag = row_sparsify[i].val;
        }

        // Retain the len_row largest entries in that row
        kLargest(row_sparsify, c_lines->len_cols[Ii], len_row);

        //	if (Ii%1 == 0)
        //	{
        //
        //		for (i=0; i<len_row; i++)
        //		{
        //			printf(" Ii : %d, col: %d, val : %f\n", Ii,
        // row_sparsify[i].col,
        // row_sparsify[i].val);
        //		}
        //	}

        for (i = 0; i < len_row; i++) {
            vals_temp[i] = row_sparsify[i].val;
            cols_temp[i] = row_sparsify[i].col;
            if (cols_temp[i] == Ii + C->my_start_idx)
                test_idx_diag = 1; // La diagonale a ete ajoutee
        }

        // the dagonal is added
        if (!test_idx_diag) {
            if (len_row > 1) {
                val_tmp = vals_temp[len_row - 2];
                col_tmp = cols_temp[len_row - 2];
                vals_temp[len_row - 2] = val_diag;
                cols_temp[len_row - 2] = Ii + C->my_start_idx;
                vals_temp[len_row - 1] = val_tmp;
                cols_temp[len_row - 1] = col_tmp;
            }
            else {
                vals_temp[0] = val_diag;
                cols_temp[0] = Ii + C->my_start_idx;
            }

            // len_row+=1;
        }

        i = len_row;

        /*Si plusieures entrees de la colonne sont egales, ont les ajoute quand
         * meme.*/
        while ((row_sparsify[i].val == row_sparsify[len_row - 1].val) &&
               (i < c_lines->len_cols[Ii])) {
            vals_temp[i] = row_sparsify[i].val;
            cols_temp[i] = row_sparsify[i].col;
            if (cols_temp[i] == Ii)
                test_idx_diag = 1;
            len_row += 1;
            i += 1;
        }

        /* On memorise les indices des lignes supprimees */

        for (int k = len_row; k < c_lines->len_cols[Ii]; k++) {
            nbr_idx_del_in[row_sparsify[k].col] += 1;
        }

        C->c_lines->len_cols[Ii] = len_row;

        /* Set up compressed lines of C */

        /*	  if (initialization)
              {
                  C->c_lines->A[Ii] = new T[len_row];
                  C->c_lines->col_idcs[Ii] = new int[len_row];
              }
        */

        /* Set up the column structure */

        memcpy(&(C->c_lines->col_idcs_buf[gap]), cols_temp, len_row * sizeof(int));
        memcpy(&(C->c_lines->col_buf[gap]), vals_temp, len_row * sizeof(T));

        C->c_lines->A[Ii] = &(C->c_lines->col_buf[gap]);
        C->c_lines->col_idcs[Ii] = &(C->c_lines->col_idcs_buf[gap]);

        gap += len_row;

        my_local_nnz += len_row;
    }

    delete[] row_sparsify;

    delete[] vals_temp;
    delete[] cols_temp;

    /* Update matrix caracteristics */
    C->my_nnz = my_local_nnz;

    /*Get length of all columns */
    MPI_Barrier(world);
    MPI_Allgatherv(static_cast<void*>(C->c_lines->len_cols), C->my_nbr_cols,
                   MPI_INT, static_cast<void*>(C->len_all_cols),
                   C->all_nbr_cols, C->start_indices, MPI_INT, world);

    /*Get length of all rows */
    MPI_Barrier(world);
    MPI_Allreduce(nbr_idx_del_in, nbr_idx_del_out, n, MPI_INT, MPI_SUM, world);

    for (int k = 0; k < n; k++)
        C->len_all_rows[k] = len_all_rows[k] - nbr_idx_del_out[k];

    for (int k = 0; k < my_nbr_cols; k++)
        C->c_lines->len_rows[k] = C->len_all_rows[C->my_start_idx + k];

    /* Get the maximum number of nnz per column/row of all pes */
    /*
    for (i = 0; i < mtx->my_nbr_cols; i++)
        if (mtx->c_lines->len_rows[i] > max)
            max = mtx->c_lines->len_rows[i];

    for (i=0; i< mtx->my_nbr_cols; i++)
        if (mtx->c_lines->len_cols[i] > max)
            max = mtx->c_lines->len_cols[i];

    MPI_Barrier(mtx->world);
    MPI_Allreduce(&max, &mtx->max_nnz, 1, MPI_INT, MPI_MAX, mtx->world);
    */

    for (i = 0; i < n; i++) {
        if (C->len_all_rows[i] > max)
            max = C->len_all_rows[i];
        if (C->len_all_cols[i] > max)
            max = C->len_all_cols[i];
    }

    C->max_nnz = max;

    delete nbr_idx_del_in;
    delete nbr_idx_del_out;

    if (initialization)
        *Mat_pattern = C;
}

template <class T>
PetscErrorCode Matrix<T>::Convert_Matrix_to_Mat(MPI_Comm comm, Matrix<double>* B, Mat** PB)
{
    PetscMPIInt siz, rank;
    PetscErrorCode ierr;
    int m, n, M, N;
    int d_nz, o_nz;
    int *d_nnz, *o_nnz;
    int i, k, global_row, global_col, first_diag_col, last_diag_col;
    PetscScalar val;
    Mat* MP = NULL;

    PetscFunctionBegin;
    ierr = MPI_Comm_size(comm, &siz);
    ierr = MPI_Comm_rank(comm, &rank);

    m = n = B->all_nbr_cols[rank];
    d_nz = o_nz = 0;

    /* Determine preallocation for MatCreateMPIAIJ */
    ierr = PetscMalloc1(m, &d_nnz);
    ierr = PetscMalloc1(m, &o_nnz);
    MP = new Mat;

    for (i = 0; i < m; i++)
        d_nnz[i] = o_nnz[i] = 0;
    first_diag_col = B->my_start_idx;
    last_diag_col = first_diag_col + B->my_nbr_cols;

    for (i = 0; i < B->all_nbr_cols[rank]; i++) {
        for (k = 0; k < B->c_lines->len_cols[i]; k++) {
            global_col = B->c_lines->col_idcs[i][k];
            if ((global_col >= first_diag_col) && (global_col < last_diag_col))
                d_nnz[i]++;
            else
                o_nnz[i]++;
        }
    }

    M = N = B->n;

    /* Here we only know how to create AIJ format */
    ierr = MatCreate(comm, MP);
    CHKERRQ(ierr);
    ierr = MatSetSizes(*MP, m, n, M, N);
    CHKERRQ(ierr);
    ierr = MatSetType(*MP, MATAIJ);
    CHKERRQ(ierr);
    ierr = MatSeqAIJSetPreallocation(*MP, d_nz, d_nnz);
    CHKERRQ(ierr);
    ierr = MatMPIAIJSetPreallocation(*MP, d_nz, d_nnz, o_nz, o_nnz);
    CHKERRQ(ierr);

    for (i = 0; i < B->my_nbr_cols; i++) {
        global_row = B->my_start_idx + i;
        for (k = 0; k < B->c_lines->len_cols[i]; k++) {
            global_col = B->c_lines->col_idcs[i][k];

            val = abs_complex(B->c_lines->A[i][k]);
            ierr = MatSetValues(*MP, 1, &global_row, 1, &global_col, &val, ADD_VALUES);
        }
    }

    ierr = PetscFree(d_nnz);
    ierr = PetscFree(o_nnz);

    ierr = MatAssemblyBegin(*MP, MAT_FINAL_ASSEMBLY);
    ierr = MatAssemblyEnd(*MP, MAT_FINAL_ASSEMBLY);
    *PB = MP;
    PetscFunctionReturn(0);
}

template <class T>
PetscErrorCode Matrix<T>::Convert_Mat_to_Matrix(MPI_Comm comm, Matrix<double>** B, Mat* A)
{
    Matrix<double>* M = NULL;
    Mat AT;
    int i, j;
    int pe, start_indx;
    int A_buf_size = 0;
    int row_buf_size = 0;
    PetscErrorCode ierr;
    const int* cols = NULL;
    const double* vals = NULL;
    int n, m, mnl, nnl, nz, gap = 0, max = 0;
    PetscMPIInt size, rank;
    PetscBool isSymmetric;
    Compressed_Lines<double>* lines = NULL;
    MatInfo matinfo;

    PetscFunctionBegin;
    ierr = MPI_Comm_size(comm, &size);
    CHKERRQ(ierr);
    ierr = MPI_Comm_rank(comm, &rank);
    CHKERRQ(ierr);
    ierr = MatGetSize(*A, &m, &n);
    CHKERRQ(ierr);
    ierr = MatGetLocalSize(*A, &mnl, &nnl);
    CHKERRQ(ierr);

    M = new Matrix<double>(comm);

    M->n = n;
    M->m = m;

    M->all_nbr_cols = new int[M->num_procs];
    M->start_indices = new int[M->num_procs];
    M->pe = new int[n];

    // Use the transpose to get the row non zero structure
    ierr = MatTranspose(*A, MAT_INITIAL_MATRIX, &AT);
    CHKERRQ(ierr);

    MPI_Barrier(comm);
    ierr = MPI_Allgather(static_cast<void*>(&mnl), 1, MPI_INT,
                         static_cast<void*>(M->all_nbr_cols), 1, MPI_INT, comm);
    CHKERRQ(ierr);

    /* Filling start indices */
    M->start_indices[0] = 0;
    for (int pe = 1; pe < M->num_procs; pe++) {
        M->start_indices[pe] = M->start_indices[pe - 1] + M->all_nbr_cols[pe - 1];
    }

    /* Filling pe array */
    memset(M->pe, 0, n * sizeof(int));
    for (pe = 1; pe < M->num_procs; pe++) {
        start_indx = M->start_indices[pe];
        for (int k = 0; k < M->all_nbr_cols[pe]; k++) {
            M->pe[start_indx + k] = pe;
        }
    }

    ierr = MatEqual(*A, AT, &isSymmetric);
    CHKERRQ(ierr);

    if (isSymmetric)
        M->symmetric = true;

    M->my_nbr_cols = M->all_nbr_cols[M->my_id];
    M->my_start_idx = M->start_indices[M->my_id];

    /*number of nonzeros in each row */
    ierr = MatGetInfo(*A, MAT_GLOBAL_SUM, &matinfo);
    CHKERRQ(ierr);

    /*Number of nonzeros in each local rows*/
    ierr = MatGetInfo(*A, MAT_LOCAL, &matinfo);
    CHKERRQ(ierr);
    A_buf_size = matinfo.nz_used;
    M->my_nnz = matinfo.nz_used;

    M->c_lines = new Compressed_Lines<double>(M->my_nbr_cols, isSymmetric);

    /* Allocation of Compressed Lines */
    lines = M->c_lines;
    lines->col_buf = new double[A_buf_size];
    lines->col_idcs_buf = new int[A_buf_size];

    /*Set colums and fill compressed lines*/

    for (int col = 0; col < M->my_nbr_cols; col++) {
        ierr = MatGetRow(*A, col + M->my_start_idx, &nz, &cols, &vals);
        lines->len_cols[col] = nz;
        lines->len_scalar[col] = nz;
        lines->A[col] = &(lines->col_buf[gap]);
        lines->col_idcs[col] = &(lines->col_idcs_buf[gap]);
        gap += nz;

        for (j = 0; j < nz; j++) {
            lines->col_idcs[col][j] = cols[j];
            lines->A[col][j] = abs_complex(vals[j]);
        }

        ierr = MatRestoreRow(*A, col + M->my_start_idx, &nz, &cols, &vals);
    }

    /* Set up the row structure */

    if (!isSymmetric) {
        ierr = MatGetInfo(AT, MAT_LOCAL, &matinfo);
        CHKERRQ(ierr);
        row_buf_size = matinfo.nz_used;

        lines->row_idcs_buf = new int[row_buf_size];

        for (int row = 0, gap = 0; row < M->my_nbr_cols; row++) {
            ierr = MatGetRow(AT, row + M->my_start_idx, &nz, &cols, NULL);
            lines->len_rows[row] = nz;
            lines->row_idcs[row] = &(lines->row_idcs_buf[gap]);
            gap += nz;

            for (int r = 0; r < nz; r++)
                lines->row_idcs[row][r] = cols[r];

            ierr = MatRestoreRow(AT, row + M->my_start_idx, &nz, &cols, NULL);
        }
    }

    /* Get length of all cols*/
    M->len_all_cols = new int[M->n];
    MPI_Barrier(comm);
    MPI_Allgatherv(static_cast<void*>(lines->len_cols), M->my_nbr_cols, MPI_INT,
                   static_cast<void*>(M->len_all_cols), M->all_nbr_cols,
                   M->start_indices, MPI_INT, comm);

    /* Get length of all rows */
    M->len_all_rows = new int[M->n];
    MPI_Barrier(comm);
    MPI_Allgatherv(static_cast<void*>(lines->len_rows), M->my_nbr_cols, MPI_INT,
                   static_cast<void*>(M->len_all_rows), M->all_nbr_cols,
                   M->start_indices, MPI_INT, comm);

    /* Get the maximum number of nnz per column/row of all pes */
    for (i = 0; i < M->my_nbr_cols; i++)
        if (lines->len_rows[i] > max)
            max = lines->len_rows[i];

    for (i = 0; i < M->my_nbr_cols; i++)
        if (lines->len_cols[i] > max)
            max = lines->len_cols[i];

    MPI_Barrier(comm);
    MPI_Allreduce(&max, &M->max_nnz, 1, MPI_INT, MPI_MAX, comm);

    /* Initialize the remote transfer buffer */
    M->remote_col_buf = new double[M->max_nnz];
    memset(M->remote_col_buf, 0, M->max_nnz * sizeof(double));

    M->remote_col_send = new double[M->max_nnz];
    memset(M->remote_col_send, 0, M->max_nnz * sizeof(double));

    M->remote_col_idcs_buf = new int[M->max_nnz];
    memset(M->remote_col_idcs_buf, 0, M->max_nnz * sizeof(int));

    M->remote_row_idcs_buf = new int[M->max_nnz];
    memset(M->remote_row_idcs_buf, 0, M->max_nnz * sizeof(int));

    lines = NULL;

    M->block_size = 1;
    M->max_block_size = 1;
    M->block_sizes = new int[M->n];
    for (int k = 0; k < M->n; k++)
        M->block_sizes[k] = 1;

    delete *B;
    *B = M;

    ierr = MatDestroy(&AT);
    return ierr;
}

template <class T>
PetscErrorCode Matrix<T>::Convert_Mat_to_Matrix_Update(MPI_Comm comm, Matrix<double>** B, Mat* A)
{
    Matrix<double>* M = *B;
    Mat AT;
    int i, j;
    int pe, start_indx;
    int A_buf_size = 0;
    int row_buf_size = 0;
    PetscErrorCode ierr;
    const int* cols = NULL;
    const double* vals = NULL;
    int n, m, mnl, nnl, nz, gap = 0, max = 0;
    PetscMPIInt size, rank;
    PetscBool isSymmetric;
    Compressed_Lines<double>* lines = NULL;
    MatInfo matinfo;

    PetscFunctionBegin;
    ierr = MPI_Comm_size(comm, &size);
    CHKERRQ(ierr);
    ierr = MPI_Comm_rank(comm, &rank);
    CHKERRQ(ierr);
    ierr = MatGetSize(*A, &m, &n);
    CHKERRQ(ierr);
    ierr = MatGetLocalSize(*A, &mnl, &nnl);
    CHKERRQ(ierr);

    // Use the transpose to get the row non zero structure
    ierr = MatTranspose(*A, MAT_INITIAL_MATRIX, &AT);
    CHKERRQ(ierr);

    /*number of nonzeros in each row */
    ierr = MatGetInfo(*A, MAT_GLOBAL_SUM, &matinfo);
    CHKERRQ(ierr);

    /*Number of nonzeros in each local rows*/
    ierr = MatGetInfo(*A, MAT_LOCAL, &matinfo);
    CHKERRQ(ierr);
    A_buf_size = matinfo.nz_used;
    M->my_nnz = matinfo.nz_used;

    /*Set colums and fill compressed lines*/
    lines = M->c_lines;

    for (int col = 0; col < M->my_nbr_cols; col++) {
        ierr = MatGetRow(*A, col + M->my_start_idx, &nz, &cols, &vals);
        lines->len_cols[col] = nz;
        lines->len_scalar[col] = nz;
        lines->A[col] = &(lines->col_buf[gap]);
        lines->col_idcs[col] = &(lines->col_idcs_buf[gap]);
        gap += nz;

        for (j = 0; j < nz; j++) {
            lines->col_idcs[col][j] = cols[j];
            lines->A[col][j] = abs_complex(vals[j]);
        }

        ierr = MatRestoreRow(*A, col + M->my_start_idx, &nz, &cols, &vals);
    }

    /* Set up the row structure */

    if (!isSymmetric) {
        ierr = MatGetInfo(AT, MAT_LOCAL, &matinfo);
        CHKERRQ(ierr);

        for (int row = 0, gap = 0; row < M->my_nbr_cols; row++) {
            ierr = MatGetRow(AT, row + M->my_start_idx, &nz, &cols, NULL);
            lines->len_rows[row] = nz;
            lines->row_idcs[row] = &(lines->row_idcs_buf[gap]);
            gap += nz;

            for (int r = 0; r < nz; r++)
                lines->row_idcs[row][r] = cols[r];

            ierr = MatRestoreRow(AT, row + M->my_start_idx, &nz, &cols, NULL);
        }
    }

    /* Get length of all cols*/
    MPI_Barrier(comm);
    MPI_Allgatherv(static_cast<void*>(lines->len_cols), M->my_nbr_cols, MPI_INT,
                   static_cast<void*>(M->len_all_cols), M->all_nbr_cols,
                   M->start_indices, MPI_INT, comm);

    /* Get length of all rows */
    MPI_Barrier(comm);
    MPI_Allgatherv(static_cast<void*>(lines->len_rows), M->my_nbr_cols, MPI_INT,
                   static_cast<void*>(M->len_all_rows), M->all_nbr_cols,
                   M->start_indices, MPI_INT, comm);

    /* Get the maximum number of nnz per column/row of all pes */
    for (i = 0; i < M->my_nbr_cols; i++)
        if (lines->len_rows[i] > max)
            max = lines->len_rows[i];

    for (i = 0; i < M->my_nbr_cols; i++)
        if (lines->len_cols[i] > max)
            max = lines->len_cols[i];

    MPI_Barrier(comm);
    MPI_Allreduce(&max, &M->max_nnz, 1, MPI_INT, MPI_MAX, comm);

    lines = NULL;

    ierr = MatDestroy(&AT);
    return ierr;
}
template <class T>
PetscErrorCode Matrix<T>::Convert_Mat_to_Matrix(
    MPI_Comm comm, Matrix<double>** B, Mat* A, Vec** prob_Ce, int prob_Ce_N)
{
    /*
        Matrix<double>               *M = NULL;
        Mat			AT;
        int                     i,j;
        int                     row_indx;
        int                     len,pe,start_indx;
        int 			A_buf_size = 0;
        int 			row_buf_size = 0;
    */
    PetscErrorCode ierr;
    PetscMPIInt size, rank;
    /*
        const int               *cols = NULL;
        const double            *vals = NULL;
        int                     n,m,mnl,nnl,nz,rstart,rend,gap = 0, max = 0;
        PetscMPIInt             size,rank;
        PetscBool 		isSymmetric;
        Compressed_Lines<double> *lines = NULL;
        MatInfo                 matinfo;


        PetscScalar 		**array;
        PetscFunctionBegin;
      */
    ierr = MPI_Comm_size(comm, &size);
    CHKERRQ(ierr);
    ierr = MPI_Comm_rank(comm, &rank);
    CHKERRQ(ierr);
    /*
      ierr = MatGetSize(*A,&n,&n);CHKERRQ(ierr);
      ierr = MatGetLocalSize(*A,&mnl,&nnl);CHKERRQ(ierr);


      M = new Matrix<double>(comm);

      M->n = n;
      M->m = m;
      M->all_nbr_cols  = new int[M->num_procs];
      M->start_indices = new int[M->num_procs];
          M->pe		 = new int[n];

      //Use the transpose to get the row non zero structure
      ierr = MatTranspose(*A, MAT_INITIAL_MATRIX, &AT);CHKERRQ(ierr);


      MPI_Barrier(comm);
      ierr = MPI_Allgather(static_cast<void *>(&mnl), 1, MPI_INT,
      static_cast<void *>(M->all_nbr_cols), 1, MPI_INT, comm);CHKERRQ(ierr);
  */

    /* Filling start indices */
    /*
        M->start_indices[0] = 0;
        for (int pe = 1; pe < M->num_procs; pe++)
        {
            M->start_indices[pe] = M->start_indices[pe-1] +
       M->all_nbr_cols[pe-1];
        }
    */

    /* Filling pe array */
    /*
        memset(M->pe, 0, n*sizeof(int));
        for (pe = 1; pe < M->num_procs; pe++)
        {
            start_indx = M->start_indices[pe];
            for (int k = 0; k < M->all_nbr_cols[pe]; k++)
            {
                   M->pe[start_indx + k] = pe;
            }
        }

        ierr = MatEqual(*A, AT, &isSymmetric);CHKERRQ(ierr);


        if (isSymmetric)
            M->symmetric = true;

        M->my_nbr_cols = M->all_nbr_cols[M->my_id];
        M->my_start_idx = M->start_indices[M->my_id];
    */
    /*number of nonzeros in each row */
    /*
        ierr = MatGetInfo(*A, MAT_GLOBAL_SUM, &matinfo);CHKERRQ(ierr);
    */

    /*Number of nonzeros in each local rows*/
    /*
        ierr = MatGetInfo(*A, MAT_LOCAL, &matinfo);CHKERRQ(ierr);
        A_buf_size = matinfo.nz_used;


        array = new PetscScalar*[prob_Ce_N];
    */

    /*Initialisation du tableau array*/
    /*
        for (i=0; i<prob_Ce_N; i++)
        {
              ierr = VecGetArray(*(prob_Ce[i]),&(array[i]));CHKERRQ(ierr);
        }

        for (i=0; i<prob_Ce_N; i++)
        {
            for (j=0; j<M->my_nbr_cols; j++)
            {
                if (array[i][j]!=0)
                    A_buf_size++;
            }
        }

        M->my_nnz = A_buf_size;

        M->c_lines = new Compressed_Lines<double>(M->my_nbr_cols, isSymmetric);

    */
    /* Allocation of Compressed Lines */
    /*
        lines = M->c_lines;
        lines->col_buf = new double[A_buf_size];
        lines->col_idcs_buf = new int[A_buf_size];


    */
    /*Set colums and fill compressed lines*/
    /*

        for (int col=0; col < M->my_nbr_cols; col++)
        {
            ierr = MatGetRow(*A, col+M->my_start_idx, &nz, &cols, &vals);
            lines->len_cols[col] = nz;
            lines->A[col] = &(lines->col_buf[gap]);
            lines->col_idcs[col] = &(lines->col_idcs_buf[gap]);
            gap += nz;

            for (j=0; j<nz; j++)
            {
                lines->col_idcs[col][j]   = cols[j];
                lines->A[col][j]           = abs_complex(vals[j]);
            }

            for (j=0; j<prob_Ce_N; j++)
            {
                if (array[j][col] != 0)
                {
                    lines->col_idcs[col][nz+j]   = M->n + j;
                    lines->A[col][nz+j]          = array[j][col];
                }

            }
            ierr = MatRestoreRow(*A, col+M->my_start_idx, &nz, &cols, &vals);
        }

    */
    /* Set up the row structure */

    /*
        if (!isSymmetric)
        {

            ierr = MatGetInfo(AT, MAT_LOCAL, &matinfo);CHKERRQ(ierr);
            row_buf_size = matinfo.nz_used;

            lines->row_idcs_buf = new int[row_buf_size];


            for (int row=0, gap = 0; row < M->my_nbr_cols; row++)
            {
                ierr = MatGetRow(AT, row+M->my_start_idx, &nz, &cols, NULL);
                lines->len_rows[row] = nz;
                lines->row_idcs[row] = &(lines->row_idcs_buf[gap]);
                gap += nz;

                for (int r = 0; r < nz; r++)
                    lines->row_idcs[row][r] = cols[r];

                ierr = MatRestoreRow(AT, row+M->my_start_idx, &nz, &cols, NULL);
            }
        }

    */
    /* Get length of all cols*/
    /*
        M->len_all_cols = new int[M->n];
        MPI_Barrier(comm);
        MPI_Allgatherv(static_cast<void *>(lines->len_cols),
                       M->my_nbr_cols, MPI_INT,
                       static_cast<void *>(M->len_all_cols),
                       M->all_nbr_cols, M->start_indices,
                       MPI_INT, comm);
        */
    /* Get length of all rows */
    /*
        M->len_all_rows = new int[M->n];
        MPI_Barrier(comm);
        MPI_Allgatherv(static_cast<void *>(lines->len_rows),
                        M->my_nbr_cols, MPI_INT,
                        static_cast<void *>(M->len_all_rows),
                        M->all_nbr_cols, M->start_indices,
                        MPI_INT, comm);


    */
    /* Get the maximum number of nnz per column/row of all pes */
    /*
        for (i = 0; i < M->my_nbr_cols; i++)
            if (lines->len_rows[i] > max)
                max = lines->len_rows[i];

        for (i=0; i< M->my_nbr_cols; i++)
            if (lines->len_cols[i] > max)
                max = lines->len_cols[i];

        MPI_Barrier(comm);
        MPI_Allreduce(&max, &M->max_nnz, 1, MPI_INT, MPI_MAX, comm);
    */

    /* Initialize the remote transfer buffer */
    /*
        M->remote_col_buf = new double[M->max_nnz];
        memset(M->remote_col_buf, 0, M->max_nnz * sizeof(double));

        M->remote_col_idcs_buf = new int[M->max_nnz];
        memset(M->remote_col_idcs_buf, 0, M->max_nnz * sizeof(int));

        M->remote_row_idcs_buf = new int[M->max_nnz];
        memset(M->remote_row_idcs_buf, 0, M->max_nnz * sizeof(int));


        *B = M;

        for (i=0; i<prob_Ce_N; i++)
        {
            ierr = VecRestoreArray(*(prob_Ce[i]),&(array[i]));CHKERRQ(ierr);
        }

        delete array;

        ierr = MatDestroy(&AT);
    */
    return ierr;
}

template <class T>
Matrix<T>* Matrix<T>::Convert_Block_Matrix(Matrix<T>* A, int bs, int upper_bs_limit, int verbose)
{
    Matrix<T>* B;
    Timer o_timer;

    // Start time measurement
    if (verbose) {
        o_timer = Timer();
        o_timer.Start_Timer();
    }

    if (bs)
        B = Constant_Block_Matrix(A, bs);

    else
        B = Variable_Block_Matrix(A, upper_bs_limit);

    if (verbose) {
        // Stop time measurement
        o_timer.Stop_Timer();
        o_timer.Report_Time(A->world);
    }

    return B;
}

template <class T>
void Matrix<T>::Convert_Block_Matrix_Update(Matrix<T>* A, Matrix<T>* B, int verbose)
{
    Timer o_timer;

    // Start time measurement
    if (verbose) {
        o_timer = Timer();
        o_timer.Start_Timer();
    }

    A->Convert_To_Block_Matrix_Update(B);

    if (verbose) {
        // Stop time measurement
        o_timer.Stop_Timer();
        o_timer.Report_Time(B->world);
    }
}

template <class T>
Matrix<T>* Matrix<T>::Constant_Block_Matrix(Matrix<T>* A, int bs)
{
    Matrix<T>* V;
    int nblocks, *block_sizes;

    Find_Constant_Blocks(A, bs, block_sizes, nblocks);
    V = A->Convert_To_Block_Matrix(nblocks, block_sizes);

    V->block_size = bs;

    delete[] block_sizes;

    return V;
}

template <class T>
void Matrix<T>::Find_Constant_Blocks(Matrix<T>* A, int block_size, int*& block_sizes, int& nblocks)
{
    int odd_block;

    nblocks = (A->my_nbr_cols) / block_size;
    odd_block = (A->my_nbr_cols) % block_size;

    if (odd_block)
        nblocks++;

    block_sizes = new int[nblocks];

    for (int i = 0; i < nblocks; i++)
        block_sizes[i] = block_size;

    if (odd_block)
        block_sizes[nblocks - 1] = odd_block;
}

template <class T>
Matrix<T>* Matrix<T>::Variable_Block_Matrix(Matrix<T>* A, int upper_bs_limit)
{
    Matrix<T>* V;
    int nblocks, *block_sizes;

    Find_Diagonal_Blocks(A, upper_bs_limit, block_sizes, nblocks);
    V = A->Convert_To_Block_Matrix(nblocks, block_sizes);

    V->block_size = 0;

    delete[] block_sizes;

    return V;
}

template <class T>
void Matrix<T>::Find_Diagonal_Blocks(Matrix<T>* A, int upper_bs_limit, int*& block_sizes, int& nblocks)
{
    int* block_numbers;
    int iend, i;

    /* block numbers : map scalar column to block column */
    block_numbers = new int[A->my_nbr_cols];
    nblocks = 0;
    i = 0;

    do {
        iend = Find_Diagonal_Block(A, i, upper_bs_limit);
        for (int ii = i; ii <= iend; ii++)
            block_numbers[ii] = nblocks;
        nblocks++;
        i = iend + 1;
    } while (i < A->my_nbr_cols);

    block_sizes = new int[nblocks];
    for (int i = 0; i < nblocks; i++)
        block_sizes[i] = 0;

    for (int i = 0; i < A->my_nbr_cols; i++)
        block_sizes[block_numbers[i]]++;

    delete[] block_numbers;
}

template <class T>
int Matrix<T>::Find_Diagonal_Block(Matrix<T>* A, int i, int upper_bs_limit)
{
    int bs, max_bs;

    max_bs = Initial_Run_Length(A, i);
    bs = max_bs;

    if (max_bs == 1)
        return i;

    if (upper_bs_limit)
        if (max_bs > upper_bs_limit)
            bs = max_bs = upper_bs_limit;

    for (int k = 0; k < max_bs; k++) {
        if ((k > 0) && (i + k) == A->my_nbr_cols)
            return (i + k - 1);

        bs = Check_Next_Run(A, i, i + k, bs);
        if (!bs)
            return (i + k - 1);
    }

    return (i + max_bs - 1);
}

template <class T>
int Matrix<T>::Initial_Run_Length(Matrix<T>* A, int i)
{
    int index, row_index;
    int bs, ii;

    index = -1;
    /*Find the index of the diagonal entry, if any */
    for (int k = 0; k < (A->c_lines->len_cols[i]); k++) {
        row_index =
            A->c_lines->col_idcs[i][k]; // row of k-th entry in scalar column i
        if ((A->pe[row_index] == A->my_id) && ((row_index - A->my_start_idx) == i)) {
            index = k;
            break;
        }
    }

    /* No diagonal entry */
    if (index < 0)
        return 1;

    bs = 1;
    /* Count consecutive entries in scalar column i */
    ii = i + 1;
    for (int k = index + 1; k < (A->c_lines->len_cols[i]); k++) {
        row_index = A->c_lines->col_idcs[i][k];
        if ((A->pe[row_index] == A->my_id) && ((row_index - A->my_start_idx) == ii)) {
            bs++;
            ii++;
        }
        else {
            return bs;
        }
    }
    return bs;
}

template <class T>
int Matrix<T>::Check_Next_Run(Matrix<T>* A, int i, int i_next, int bs)
{
    /*Check if block size is fine for block i_next*/
    int index, new_bs, ii;
    int row_index;

    index = -1;
    for (int k = 0; k < (A->c_lines->len_cols[i_next]); k++) {
        row_index = A->c_lines->col_idcs[i_next][k]; // row of k-th entry in
                                                     // scalar column i_next
        if ((A->pe[row_index] == A->my_id) && ((row_index - A->my_start_idx) == i)) {
            index = k;
            break;
        }
    }

    /* return 0 if it doesn't exist */
    if (index < 0)
        return 0;

    /*Count consecutive entries */
    new_bs = 1;
    ii = i + 1;
    for (int k = index + 1; k < (A->c_lines->len_cols[i_next]); k++) {
        row_index = A->c_lines->col_idcs[i_next][k];
        if ((A->pe[row_index] == A->my_id) && ((row_index - A->my_start_idx) == ii)) {
            new_bs++;
            ii++;
        }
        else
            break;
    }

    /*Does the run include the diagonal entry of i_next?*/
    if (new_bs > i_next - i) {
        /*Yes it does*/
        if (new_bs > bs)
            return bs;
        else
            return new_bs;
    }

    return 0;
}

template <class T>
Matrix<T>* Matrix<T>::Convert_To_Block_Matrix(int nblocks_local, int* block_sizes_local)
{
    int max_n = 0, count = 0, total_height = 0;
    int *block_bitvec = NULL, *block_start = NULL;
    double* fullcol;
    double infinity = 1.0E300;
    int* block_index_map = NULL;
    int max_block_columns;
    int idx, jcol, k, m1, n1, next;
    int jb, ib, start, start_idx;

    int col_buf_size, row_buf_size, A_buf_size;
    int max_col_buf_size, max_row_buf_size, max_A_buf_size;

    int *ptr_adr = NULL, *rptr_adr = NULL;
    double* A_adr = NULL;
    int next_ptr, next_rptr, next_Aptr;
    int num;
    int B_my_nnz = 0;

    Matrix<double>* B;
    B = new Matrix<double>(world);

    B->all_nbr_cols = new int[B->num_procs];
    B->start_indices = new int[B->num_procs];

    B->symmetric = symmetric;

    // Filling all_nbr_cols
    MPI_Barrier(B->world);
    MPI_Allgather(static_cast<void*>(&nblocks_local), 1, MPI_INT,
                  static_cast<void*>(B->all_nbr_cols), 1, MPI_INT, B->world);

    max_block_columns = 0;
    for (int i_pe = 0; i_pe < B->num_procs; i_pe++) {
        if (max_block_columns < B->all_nbr_cols[i_pe])
            max_block_columns = B->all_nbr_cols[i_pe];
    }

    B->my_nbr_cols = B->all_nbr_cols[B->my_id];

    B->n = 0;
    for (int i = 0; i < B->num_procs; i++) {
        B->n += B->all_nbr_cols[i];
    }

    /* B is square */
    B->m = B->n;

    /*start indices : index of the block column*/
    B->start_indices[0] = 0;
    B->pe = new int[B->n];
    for (int i_pe = 1; i_pe < B->num_procs; i_pe++) {
        B->start_indices[i_pe] = B->start_indices[i_pe - 1] + B->all_nbr_cols[i_pe - 1];
    }

    B->my_start_idx = B->start_indices[B->my_id];

    for (int ipe = 0; ipe < (B->num_procs); ipe++) {
        start_idx = B->start_indices[ipe];
        for (int col = 0; col < (B->all_nbr_cols[ipe]); col++)
            B->pe[start_idx + col] = ipe;
    }

    // Define the block size of all the block columns of B
    B->block_sizes = new int[B->n];

    MPI_Barrier(B->world);
    MPI_Allgatherv(static_cast<void*>(block_sizes_local), B->my_nbr_cols,
                   MPI_INT, static_cast<void*>(B->block_sizes), B->all_nbr_cols,
                   B->start_indices, MPI_INT, B->world);

    B->block_size = 0;

    for (ib = 0; ib < (B->n); ib++) {
        if (max_n < B->block_sizes[ib])
            max_n = B->block_sizes[ib];
    }

    B->max_block_size = max_n;

    /* Creation of B column sructure */
    B->c_lines = new Compressed_Lines<double>(B->my_nbr_cols, symmetric);

    fullcol = new double[n * max_n];
    block_bitvec = new int[B->n];

    for (int k = 0; k < (n)*max_n; k++)
        fullcol[k] = infinity;

    for (ib = 0; ib < B->n; ib++)
        block_bitvec[ib] = 0;

    /* Mapping of scalar indices to block indices */
    /// block_index_map[ col in A] = col in B

    int idx_map = 0;

    block_index_map = new int[n];
    for (ib = 0; ib < B->n; ib++) {
        for (int k = 0; k < B->block_sizes[ib]; k++)
            block_index_map[idx_map + k] = ib;

        idx_map += B->block_sizes[ib];
    }

    /* block_start[ib] gives the index of the first scalar column in block i */
    block_start = new int[B->n];
    block_start[0] = 0;
    for (ib = 1; ib < B->n; ib++)
        block_start[ib] = block_start[ib - 1] + B->block_sizes[ib - 1];

    /* Fill the columns */
    // Sweep sub block columns in a processor
    //
    jb = 0;
    for (int startj = 0; jb < max_block_columns; jb++) {
        if (jb < B->my_nbr_cols) {
            n1 = block_sizes_local[jb];
            count = 0;        /* number of blocks in this block column jb */
            total_height = 0; /*number of entries in column block jb (only
                                 height not width)*/

            /*fill fullcol*/
            // Sweep scalar columns in block column jb
            for (int j = startj; j < startj + n1; j++) {
                // Seep elements of A in scalar column j
                for (int k = 0; k < c_lines->len_cols[j]; k++) {
                    idx = c_lines->col_idcs[j][k]; // row index of element
                                                   // [j][k]
                    jcol = j - startj;
                    fullcol[jcol * n + idx] = c_lines->A[j][k];

                    ib = block_index_map[idx];
                    if (!block_bitvec[ib]) {
                        block_bitvec[ib] = 1;
                        count++;
                        total_height += B->block_sizes[ib];
                    }
                }
            }

            /* Install block column jb */
            B->c_lines->col_idcs[jb] = new int[count];
            B->c_lines->A[jb] = new double[total_height * n1];

            B->c_lines->len_cols[jb] = count;
            B->c_lines->len_scalar[jb] = total_height;

            B_my_nnz += total_height;

            /*Sweep Block rows of B in block column jb*/
            k = 0;
            next = 0;
            for (ib = 0; ib < B->n; ib++) {
                /*if this block row is present */
                if (block_bitvec[ib]) {
                    B->c_lines->col_idcs[jb][k] = ib;
                    start = block_start[ib];
                    m1 = B->block_sizes[ib];
                    for (int col = 0; col < n1; col++) {
                        for (int row = 0; row < m1; row++) {
                            if (fullcol[start + col * n + row] == infinity) {
                                fullcol[start + col * n + row] = 0.0;
                            }
                            B->c_lines->A[jb][next + col * m1 + row] =
                                fullcol[start + col * n + row];
                            fullcol[start + col * n + row] = infinity;
                        }
                    }

                    block_bitvec[ib] = 0;

                    k++;
                    next += m1 * n1;
                }
            }
        }
        startj += block_sizes_local[jb];
    }

    /*i and j : column and row indices in the scalar matrix
     * ib and jb : column and row indices in the block matrix*/

    if (c_lines->row_idcs_buf) {
        B->c_lines->row_idcs = new int*[B->my_nbr_cols];
        jb = 0;
        for (int startj = 0; jb < max_block_columns; startj += block_sizes_local[jb], jb++) {
            if (jb < B->my_nbr_cols) {
                n1 = block_sizes_local[jb];
                count = 0; /*number of blocks in this block row jb*/

                /*fill fullcol (actually fullrow)*/
                for (int j = startj; j < startj + n1; j++) {
                    for (k = 0; k < c_lines->len_rows[j]; k++) {
                        idx = c_lines->row_idcs[j][k];
                        jcol = j - startj;
                        fullcol[jcol * n + idx] = 1.0;

                        ib = block_index_map[idx];
                        if (!block_bitvec[ib]) {
                            block_bitvec[ib] = 1;
                            count++;
                            block_start[ib] = idx;
                        }
                    }
                }

                /*Install block row structure*/
                B->c_lines->row_idcs[jb] = new int[count];
                B->c_lines->len_rows[jb] = count;
                k = 0;
                next = 0;
                for (ib = 0; ib < B->n; ib++) {
                    if (block_bitvec[ib]) {
                        B->c_lines->row_idcs[jb][k] = ib;
                        k++;
                        next += m1 * n1;
                        block_bitvec[ib] = 0;
                    }
                }
            }
        }
    }

    /*Convert row and column data to consistent buffers*/

    col_buf_size = 0;
    row_buf_size = 0;
    A_buf_size = 0;

    idx = B->my_start_idx;
    for (int j = 0; j < B->my_nbr_cols; j++, idx++) {
        col_buf_size += B->c_lines->len_cols[j];
        if (B->c_lines->row_idcs)
            row_buf_size += B->c_lines->len_rows[j];
        A_buf_size += (B->block_sizes[idx] * B->c_lines->len_scalar[j]);
    }

    MPI_Barrier(world);
    MPI_Allreduce(static_cast<void*>(&col_buf_size),
                  static_cast<void*>(&max_col_buf_size), 1, MPI_INT, MPI_MAX, world);

    if (B->c_lines->row_idcs)
        MPI_Allreduce(static_cast<void*>(&row_buf_size),
                      static_cast<void*>(&max_row_buf_size), 1, MPI_INT, MPI_MAX, world);

    MPI_Allreduce(static_cast<void*>(&A_buf_size),
                  static_cast<void*>(&max_A_buf_size), 1, MPI_INT, MPI_MAX, world);

    B->c_lines->col_idcs_buf = new int[max_col_buf_size];
    if (B->c_lines->row_idcs)
        B->c_lines->row_idcs_buf = new int[max_row_buf_size];
    B->c_lines->col_buf = new double[max_A_buf_size];

    ptr_adr = (B->c_lines->col_idcs_buf);
    rptr_adr = (B->c_lines->row_idcs_buf);
    A_adr = (B->c_lines->col_buf);
    idx = B->my_start_idx;

    next_ptr = 0;
    next_rptr = 0;
    next_Aptr = 0;

    for (int j = 0; j < B->my_nbr_cols; j++, idx++) {
        num = B->c_lines->len_cols[j];
        memcpy(&(B->c_lines->col_idcs_buf[next_ptr]), B->c_lines->col_idcs[j],
               num * sizeof(int));
        next_ptr += B->c_lines->len_cols[j];
        delete[] B->c_lines->col_idcs[j];
        B->c_lines->col_idcs[j] = ptr_adr;
        ptr_adr += B->c_lines->len_cols[j];

        if (B->c_lines->row_idcs) {
            num = B->c_lines->len_rows[j];
            memcpy(&(B->c_lines->row_idcs_buf[next_rptr]),
                   B->c_lines->row_idcs[j], num * sizeof(int));
            next_rptr += B->c_lines->len_rows[j];
            delete[] B->c_lines->row_idcs[j];
            B->c_lines->row_idcs[j] = rptr_adr;
            rptr_adr += B->c_lines->len_rows[j];
        }

        num = B->block_sizes[idx] * B->c_lines->len_scalar[j];
        memcpy(&(B->c_lines->col_buf[next_Aptr]), B->c_lines->A[j], num * sizeof(double));
        next_Aptr += B->block_sizes[idx] * B->c_lines->len_scalar[j];

        delete[] B->c_lines->A[j];
        B->c_lines->A[j] = A_adr;
        A_adr += B->block_sizes[idx] * B->c_lines->len_scalar[j];
    }

    /* Get length of all cols*/
    B->len_all_cols = new int[B->n];
    MPI_Barrier(B->world);
    MPI_Allgatherv(static_cast<void*>(B->c_lines->len_cols), B->my_nbr_cols,
                   MPI_INT, static_cast<void*>(B->len_all_cols),
                   B->all_nbr_cols, B->start_indices, MPI_INT, B->world);

    /* Get length of all rows */
    B->len_all_rows = new int[B->n];
    MPI_Barrier(B->world);
    MPI_Allgatherv(static_cast<void*>(B->c_lines->len_rows), B->my_nbr_cols,
                   MPI_INT, static_cast<void*>(B->len_all_rows),
                   B->all_nbr_cols, B->start_indices, MPI_INT, B->world);

    int max = 0;

    /* Get the maximum number of nnz per column/row of all pes */
    for (int i = 0; i < B->my_nbr_cols; i++)
        if (B->c_lines->len_rows[i] > max)
            max = B->c_lines->len_rows[i];

    for (int i = 0; i < B->my_nbr_cols; i++)
        if (B->c_lines->len_cols[i] > max)
            max = B->c_lines->len_cols[i];

    B->my_nnz = B_my_nnz;

    MPI_Barrier(B->world);
    MPI_Allreduce(&max, &(B->max_nnz), 1, MPI_INT, MPI_MAX, B->world);

    B->max_nnz *= B->max_block_size * B->max_block_size;

    /* Initialize the remote transfer buffer */
    B->remote_col_buf = new double[B->max_nnz];
    memset(B->remote_col_buf, 0, B->max_nnz * sizeof(double));

    B->remote_col_send = new double[B->max_nnz];
    memset(B->remote_col_send, 0, B->max_nnz * sizeof(double));

    B->remote_col_idcs_buf = new int[B->max_nnz];
    memset(B->remote_col_idcs_buf, 0, B->max_nnz * sizeof(int));

    B->remote_row_idcs_buf = new int[B->max_nnz];
    memset(B->remote_row_idcs_buf, 0, B->max_nnz * sizeof(int));

    delete[] fullcol;
    delete[] block_bitvec;
    delete[] block_start;
    delete[] block_index_map;

    return B;
}

template <class T>
void Matrix<T>::Convert_To_Block_Matrix_Update(Matrix<T>* B)
{
    int max_n = 0, count = 0, total_height = 0;
    int *block_bitvec = NULL, *block_start = NULL;
    double* fullcol;
    double infinity = 1.0E300;
    int* block_index_map = NULL;
    int max_block_columns;
    int idx, jcol, k, m1, n1, next;
    int jb, ib, start, start_idx;

    int col_buf_size, row_buf_size, A_buf_size;
    int max_col_buf_size, max_row_buf_size, max_A_buf_size;

    int *ptr_adr = NULL, *rptr_adr = NULL;
    double* A_adr = NULL;
    int next_ptr, next_rptr, next_Aptr;
    int num;
    int B_my_nnz = 0;

    max_n = B->max_block_size;

    fullcol = new double[n * max_n];
    block_bitvec = new int[B->n];

    for (int k = 0; k < (n)*max_n; k++)
        fullcol[k] = infinity;

    for (ib = 0; ib < B->n; ib++)
        block_bitvec[ib] = 0;

    max_block_columns = 0;
    for (int i_pe = 0; i_pe < B->num_procs; i_pe++) {
        if (max_block_columns < B->all_nbr_cols[i_pe])
            max_block_columns = B->all_nbr_cols[i_pe];
    }

    /* Mapping of scalar indices to block indices */
    /// block_index_map[ col in A] = col in B

    int idx_map = 0;

    block_index_map = new int[n];
    for (ib = 0; ib < B->n; ib++) {
        for (int k = 0; k < B->block_sizes[ib]; k++)
            block_index_map[idx_map + k] = ib;

        idx_map += B->block_sizes[ib];
    }

    /* block_start[ib] gives the index of the first scalar column in block i */
    block_start = new int[B->n];
    block_start[0] = 0;
    for (ib = 1; ib < B->n; ib++)
        block_start[ib] = block_start[ib - 1] + B->block_sizes[ib - 1];

    /* Fill the columns */
    // Sweep sub block columns in a processor
    //
    jb = 0;
    for (int startj = 0; jb < max_block_columns; jb++) {
        if (jb < B->my_nbr_cols) {
            n1 = B->block_sizes[B->my_start_idx + jb];
            count = 0;        /* number of blocks in this block column jb */
            total_height = 0; /*number of entries in column block jb (only
                                 height not width)*/

            /*fill fullcol*/
            // Sweep scalar columns in block column jb
            for (int j = startj; j < startj + n1; j++) {
                // Seep elements of A in scalar column j
                for (int k = 0; k < c_lines->len_cols[j]; k++) {
                    idx = c_lines->col_idcs[j][k]; // row index of element
                                                   // [j][k]
                    jcol = j - startj;
                    fullcol[jcol * n + idx] = c_lines->A[j][k];

                    ib = block_index_map[idx];
                    if (!block_bitvec[ib]) {
                        block_bitvec[ib] = 1;
                        count++;
                        total_height += B->block_sizes[ib];
                    }
                }
            }

            B_my_nnz += total_height;

            /*Sweep Block rows of B in block column jb*/
            k = 0;
            next = 0;
            for (ib = 0; ib < B->n; ib++) {
                /*if this block row is present */
                if (block_bitvec[ib]) {
                    B->c_lines->col_idcs[jb][k] = ib;
                    start = block_start[ib];
                    m1 = B->block_sizes[ib];
                    for (int col = 0; col < n1; col++) {
                        for (int row = 0; row < m1; row++) {
                            if (fullcol[start + col * n + row] == infinity) {
                                fullcol[start + col * n + row] = 0.0;
                            }
                            B->c_lines->A[jb][next + col * m1 + row] =
                                fullcol[start + col * n + row];
                            fullcol[start + col * n + row] = infinity;
                        }
                    }

                    block_bitvec[ib] = 0;

                    k++;
                    next += m1 * n1;
                }
            }
        }
        startj += B->block_sizes[B->my_start_idx + jb];
    }

    /*i and j : column and row indices in the scalar matrix
     * ib and jb : column and row indices in the block matrix*/

    if (c_lines->row_idcs_buf) {
        jb = 0;
        for (int startj = 0; jb < max_block_columns;
             startj += B->block_sizes[B->my_start_idx + jb], jb++) {
            if (jb < B->my_nbr_cols) {
                n1 = B->block_sizes[B->my_start_idx + jb];
                count = 0; /*number of blocks in this block row jb*/

                /*fill fullcol (actually fullrow)*/
                for (int j = startj; j < startj + n1; j++) {
                    for (k = 0; k < c_lines->len_rows[j]; k++) {
                        idx = c_lines->row_idcs[j][k];
                        jcol = j - startj;
                        fullcol[jcol * n + idx] = 1.0;

                        ib = block_index_map[idx];
                        if (!block_bitvec[ib]) {
                            block_bitvec[ib] = 1;
                            count++;
                            block_start[ib] = idx;
                        }
                    }
                }

                /*Install block row structure*/
                k = 0;
                next = 0;
                for (ib = 0; ib < B->n; ib++) {
                    if (block_bitvec[ib]) {
                        B->c_lines->row_idcs[jb][k] = ib;
                        k++;
                        next += m1 * n1;
                        block_bitvec[ib] = 0;
                    }
                }
            }
        }
    }

    delete[] fullcol;
    delete[] block_bitvec;
    delete[] block_start;
    delete[] block_index_map;
}

template <class T>
Matrix<T>* Matrix<T>::Convert_To_Block_Matrix_2(int nblocks_local, int* block_sizes_local)
{
    int max_n = 0, count = 0, total_height = 0;
    int *block_bitvec = NULL, *block_start = NULL;
    double* fullcol;
    double infinity = 1.0E300;
    int* block_index_map = NULL;
    int max_block_columns;
    int idx, jcol, k, m1, n1, next;
    int jb, ib, start, start_idx;

    int col_buf_size, row_buf_size, A_buf_size;
    int max_col_buf_size, max_row_buf_size, max_A_buf_size;

    int *ptr_adr = NULL, *rptr_adr = NULL;
    double* A_adr = NULL;
    int next_ptr, next_rptr, next_Aptr;
    int num;
    int B_my_nnz = 0;

    Matrix<double>* B;
    B = new Matrix<double>(world);

    B->all_nbr_cols = new int[B->num_procs];
    B->start_indices = new int[B->num_procs];

    // Filling all_nbr_cols
    MPI_Barrier(B->world);
    MPI_Allgather(static_cast<void*>(&nblocks_local), 1, MPI_INT,
                  static_cast<void*>(B->all_nbr_cols), 1, MPI_INT, B->world);

    max_block_columns = 0;
    for (int i_pe = 0; i_pe < B->num_procs; i_pe++) {
        if (max_block_columns < B->all_nbr_cols[i_pe])
            max_block_columns = B->all_nbr_cols[i_pe];
    }

    B->my_nbr_cols = B->all_nbr_cols[B->my_id];

    B->n = 0;
    for (int i = 0; i < B->num_procs; i++) {
        B->n += B->all_nbr_cols[i];
    }

    /* B is square */
    B->m = B->n;

    /*start indices : index of the block column*/
    B->start_indices[0] = 0;
    B->pe = new int[B->n];
    for (int i_pe = 1; i_pe < B->num_procs; i_pe++) {
        B->start_indices[i_pe] = B->start_indices[i_pe - 1] + B->all_nbr_cols[i_pe - 1];
    }

    B->my_start_idx = B->start_indices[B->my_id];

    for (int ipe = 0; ipe < (B->num_procs); ipe++) {
        start_idx = B->start_indices[ipe];
        for (int col = 0; col < (B->all_nbr_cols[ipe]); col++)
            B->pe[start_idx + col] = ipe;
    }

    // Define the block size of all the block columns of B
    B->block_sizes = new int[B->n];

    MPI_Barrier(B->world);
    MPI_Allgatherv(static_cast<void*>(block_sizes_local), B->my_nbr_cols,
                   MPI_INT, static_cast<void*>(B->block_sizes), B->all_nbr_cols,
                   B->start_indices, MPI_INT, B->world);

    B->block_size = B->block_sizes[0];

    for (ib = 0; ib < (B->n); ib++) {
        if (max_n < B->block_sizes[ib])
            max_n = B->block_sizes[ib];
    }

    B->max_block_size = max_n;

    /* Creation of B column sructure */
    B->c_lines = new Compressed_Lines<double>(B->my_nbr_cols, symmetric);

    fullcol = new double[n * max_n];
    block_bitvec = new int[B->n];

    for (int k = 0; k < (n)*max_n; k++)
        fullcol[k] = infinity;

    for (ib = 0; ib < B->n; ib++)
        block_bitvec[ib] = 0;

    /* Mapping of scalar indices to block indices */
    /// block_index_map[ col in A] = col in B

    int idx_map = 0;

    block_index_map = new int[n];
    for (ib = 0; ib < B->n; ib++) {
        for (int k = 0; k < B->block_sizes[ib]; k++)
            block_index_map[idx_map + k] = ib;

        idx_map += B->block_sizes[ib];
    }

    /* block_start[ib] gives the index of the first scalar column in block i */
    block_start = new int[B->n];
    block_start[0] = 0;
    for (ib = 1; ib < B->n; ib++)
        block_start[ib] = block_start[ib - 1] + B->block_sizes[ib - 1];

    /* Fill the columns */
    // Sweep sub block columns in a processor
    //

    /* Preallocation of arrays */
    // printf("start\n");
    B->c_lines->col_idcs_buf = new int[my_nnz * B->block_size];
    B->c_lines->col_buf = new double[my_nnz * B->block_size * B->block_size];
    B->c_lines->row_idcs_buf = new int[my_nnz * B->block_size];
    // printf("n1 : %d, n2 : %d\n", my_nnz * B->block_size, my_nnz *
    // B->block_size * B->block_size);

    int col_idcs_idx = 0;
    int A_idx = 0;

    jb = 0;
    for (int startj = 0; jb < max_block_columns; jb++) {
        //      printf("jb : %d, max_block : %d\n", jb, max_block_columns);
        if (jb < B->my_nbr_cols) {
            //    printf("N1 : %d, N2 : %d\n", col_idcs_idx, A_idx);

            B->c_lines->col_idcs[jb] = &(B->c_lines->col_idcs_buf[col_idcs_idx]);
            B->c_lines->A[jb] = &(B->c_lines->col_buf[A_idx]);

            n1 = block_sizes_local[jb];
            count = 0;        /* number of blocks in this block column jb */
            total_height = 0; /*number of entries in column block jb (only
                                 height not width)*/

            /*fill fullcol*/
            // Sweep scalar columns in block column jb
            for (int j = startj; j < startj + n1; j++) {
                // Seep elements of A in scalar column j
                for (int k = 0; k < c_lines->len_cols[j]; k++) {
                    idx = c_lines->col_idcs[j][k]; // row index of element
                                                   // [j][k]
                    jcol = j - startj;
                    fullcol[jcol * n + idx] = c_lines->A[j][k];

                    ib = block_index_map[idx];
                    if (!block_bitvec[ib]) {
                        block_bitvec[ib] = 1;
                        count++;
                        total_height += B->block_sizes[ib];
                    }
                }
            }

            /* Install block column jb */
            // B->c_lines->col_idcs[jb] = new int[count];
            // B->c_lines->A[jb] = new double[total_height * n1];

            B->c_lines->len_cols[jb] = count;
            B->c_lines->len_scalar[jb] = total_height;

            B_my_nnz += total_height;

            /*Sweep Block rows of B in block column jb*/
            k = 0;
            next = 0;
            for (ib = 0; ib < B->n; ib++) {
                /*if this block row is present */
                if (block_bitvec[ib]) {
                    B->c_lines->col_idcs[jb][k] = ib;
                    start = block_start[ib];
                    m1 = B->block_sizes[ib];
                    for (int col = 0; col < n1; col++) {
                        for (int row = 0; row < m1; row++) {
                            if (fullcol[start + col * n + row] == infinity) {
                                fullcol[start + col * n + row] = 0.0;
                            }
                            B->c_lines->A[jb][next + col * m1 + row] =
                                fullcol[start + col * n + row];
                            fullcol[start + col * n + row] = infinity;
                        }
                    }

                    block_bitvec[ib] = 0;

                    k++;
                    next += m1 * n1;
                }
            }

            col_idcs_idx += count;
            A_idx += total_height * n1;
        }
        startj += block_sizes_local[jb];
    }

    /*i and j : column and row indices in the scalar matrix
     * ib and jb : column and row indices in the block matrix*/
    int row_idx = 0;

    if (c_lines->row_idcs_buf) {
        B->c_lines->row_idcs = new int*[B->my_nbr_cols];
        B->c_lines->row_idcs_buf = new int[my_nnz * B->block_size];
        jb = 0;
        for (int startj = 0; jb < max_block_columns; startj += block_sizes_local[jb], jb++) {
            if (jb < B->my_nbr_cols) {
                B->c_lines->row_idcs[jb] = &(B->c_lines->row_idcs_buf[row_idx]);
                n1 = block_sizes_local[jb];
                count = 0; /*number of blocks in this block row jb*/

                /*fill fullcol (actually fullrow)*/

                for (int j = startj; j < startj + n1; j++) {
                    for (k = 0; k < c_lines->len_rows[j]; k++) {
                        idx = c_lines->row_idcs[j][k];
                        jcol = j - startj;
                        fullcol[jcol * n + idx] = 1.0;

                        ib = block_index_map[idx];
                        if (!block_bitvec[ib]) {
                            block_bitvec[ib] = 1;
                            count++;
                            block_start[ib] = idx;
                        }
                    }
                }

                /*Install block row structure*/
                B->c_lines->row_idcs[jb] = new int[count];
                B->c_lines->len_rows[jb] = count;
                k = 0;
                next = 0;
                for (ib = 0; ib < B->n; ib++) {
                    if (block_bitvec[ib]) {
                        B->c_lines->row_idcs[jb][k] = ib;
                        k++;
                        next += m1 * n1;
                        block_bitvec[ib] = 0;
                    }
                }
            }

            row_idx += count;
        }
    }

    /*Convert row and column data to consistent buffers*/

    /*
    col_buf_size = 0;
    row_buf_size = 0;
    A_buf_size = 0;

    idx = B->my_start_idx;
    for (int j = 0; j < B->my_nbr_cols; j++, idx++) {
        col_buf_size += B->c_lines->len_cols[j];
        if (B->c_lines->row_idcs)
            row_buf_size += B->c_lines->len_rows[j];
        A_buf_size += (B->block_sizes[idx] * B->c_lines->len_scalar[j]);
    }

    MPI_Barrier(world);
    MPI_Allreduce(static_cast<void*>(&col_buf_size),
                  static_cast<void*>(&max_col_buf_size), 1, MPI_INT, MPI_MAX,
    world);

    if (B->c_lines->row_idcs)
        MPI_Allreduce(static_cast<void*>(&row_buf_size),
                      static_cast<void*>(&max_row_buf_size), 1, MPI_INT,
    MPI_MAX, world);

    MPI_Allreduce(static_cast<void*>(&A_buf_size),
                  static_cast<void*>(&max_A_buf_size), 1, MPI_INT, MPI_MAX,
    world);

    B->c_lines->col_idcs_buf = new int[max_col_buf_size];
    if (B->c_lines->row_idcs)
        B->c_lines->row_idcs_buf = new int[max_row_buf_size];
    B->c_lines->col_buf = new double[max_A_buf_size];

    ptr_adr = (B->c_lines->col_idcs_buf);
    rptr_adr = (B->c_lines->row_idcs_buf);
    A_adr = (B->c_lines->col_buf);
    idx = B->my_start_idx;

    next_ptr = 0;
    next_rptr = 0;
    next_Aptr = 0;

    for (int j = 0; j < B->my_nbr_cols; j++, idx++) {
        num = B->c_lines->len_cols[j];
        memcpy(&(B->c_lines->col_idcs_buf[next_ptr]), B->c_lines->col_idcs[j],
               num * sizeof(int));
        next_ptr += B->c_lines->len_cols[j];
        delete[] B->c_lines->col_idcs[j];
        B->c_lines->col_idcs[j] = ptr_adr;
        ptr_adr += B->c_lines->len_cols[j];

        if (B->c_lines->row_idcs) {
            num = B->c_lines->len_rows[j];
            memcpy(&(B->c_lines->row_idcs_buf[next_rptr]),
                   B->c_lines->row_idcs[j], num * sizeof(int));
            next_rptr += B->c_lines->len_rows[j];
            delete[] B->c_lines->row_idcs[j];
            B->c_lines->row_idcs[j] = rptr_adr;
            rptr_adr += B->c_lines->len_rows[j];
        }

        num = B->block_sizes[idx] * B->c_lines->len_scalar[j];
        memcpy(&(B->c_lines->col_buf[next_Aptr]), B->c_lines->A[j], num *
    sizeof(double));
        next_Aptr += B->block_sizes[idx] * B->c_lines->len_scalar[j];

        delete[] B->c_lines->A[j];
        B->c_lines->A[j] = A_adr;
        A_adr += B->block_sizes[idx] * B->c_lines->len_scalar[j];
    }*/

    /* Get length of all cols*/
    B->len_all_cols = new int[B->n];
    MPI_Barrier(B->world);
    MPI_Allgatherv(static_cast<void*>(B->c_lines->len_cols), B->my_nbr_cols,
                   MPI_INT, static_cast<void*>(B->len_all_cols),
                   B->all_nbr_cols, B->start_indices, MPI_INT, B->world);

    /* Get length of all rows */

    B->len_all_rows = new int[B->n];
    MPI_Barrier(B->world);
    MPI_Allgatherv(static_cast<void*>(B->c_lines->len_rows), B->my_nbr_cols,
                   MPI_INT, static_cast<void*>(B->len_all_rows),
                   B->all_nbr_cols, B->start_indices, MPI_INT, B->world);

    int max = 0;

    /* Get the maximum number of nnz per column/row of all pes */
    for (int i = 0; i < B->my_nbr_cols; i++)
        if (B->c_lines->len_rows[i] > max)
            max = B->c_lines->len_rows[i];

    for (int i = 0; i < B->my_nbr_cols; i++)
        if (B->c_lines->len_cols[i] > max)
            max = B->c_lines->len_cols[i];

    B->my_nnz = B_my_nnz;

    MPI_Barrier(B->world);
    MPI_Allreduce(&max, &B->max_nnz, 1, MPI_INT, MPI_MAX, B->world);

    B->max_nnz *= B->max_block_size * B->max_block_size;

    /* Initialize the remote transfer buffer */
    B->remote_col_buf = new double[B->max_nnz];
    memset(B->remote_col_buf, 0, B->max_nnz * sizeof(double));

    B->remote_col_send = new double[B->max_nnz];
    memset(B->remote_col_send, 0, B->max_nnz * sizeof(double));

    B->remote_col_idcs_buf = new int[B->max_nnz];
    memset(B->remote_col_idcs_buf, 0, B->max_nnz * sizeof(int));

    B->remote_row_idcs_buf = new int[B->max_nnz];
    memset(B->remote_row_idcs_buf, 0, B->max_nnz * sizeof(int));

    delete[] fullcol;
    delete[] block_bitvec;
    delete[] block_start;
    delete[] block_index_map;

    return B;
}
/*
template <class T>
Matrix<T>* Matrix<T>::Convert_To_Block_Matrix_2(int nblocks_local, int* block_sizes_local)
{
    int max_n = 0, count = 0, total_height = 0;
    int *block_bitvec = NULL, *block_start = NULL;
    double* fullcol;
    double infinity = 1.0E300;
    int* block_index_map = NULL;
    int max_block_columns;
    int idx, jcol, k, m1, n1, next;
    int jb, ib, start, start_idx;

    int col_buf_size, row_buf_size, A_buf_size;
    int max_col_buf_size, max_row_buf_size, max_A_buf_size;

    int *ptr_adr = NULL, *rptr_adr = NULL;
    double* A_adr = NULL;
    int next_ptr, next_rptr, next_Aptr;
    int num;
    int B_my_nnz = 0;

    Matrix<double>* B;
    B = new Matrix<double>(world);

    B->all_nbr_cols = new int[B->num_procs];
    B->start_indices = new int[B->num_procs];

    // Filling all_nbr_cols
    MPI_Barrier(B->world);
    MPI_Allgather(static_cast<void*>(&nblocks_local), 1, MPI_INT,
                  static_cast<void*>(B->all_nbr_cols), 1, MPI_INT, B->world);

    max_block_columns = 0;
    for (int i_pe = 0; i_pe < B->num_procs; i_pe++) {
        if (max_block_columns < B->all_nbr_cols[i_pe])
            max_block_columns = B->all_nbr_cols[i_pe];
    }

    B->my_nbr_cols = B->all_nbr_cols[B->my_id];

    B->n = 0;
    for (int i = 0; i < B->num_procs; i++) {
        B->n += B->all_nbr_cols[i];
    }

    B->m = B->n;

    B->start_indices[0] = 0;
    B->pe = new int[B->n];
    for (int i_pe = 1; i_pe < B->num_procs; i_pe++) {
        B->start_indices[i_pe] = B->start_indices[i_pe - 1] + B->all_nbr_cols[i_pe - 1];
    }

    B->my_start_idx = B->start_indices[B->my_id];

    for (int ipe = 0; ipe < (B->num_procs); ipe++) {
        start_idx = B->start_indices[ipe];
        for (int col = 0; col < (B->all_nbr_cols[ipe]); col++)
            B->pe[start_idx + col] = ipe;
    }

    // Define the block size of all the block columns of B
    B->block_sizes = new int[B->n];

    MPI_Barrier(B->world);
    MPI_Allgatherv(static_cast<void*>(block_sizes_local), B->my_nbr_cols,
                   MPI_INT, static_cast<void*>(B->block_sizes), B->all_nbr_cols,
                   B->start_indices, MPI_INT, B->world);

    B->block_size = B->block_sizes[0];


    B->max_block_size = B->block_size;

    B->c_lines = new Compressed_Lines<double>(B->my_nbr_cols, symmetric);

    fullcol = new double[n * max_n];
    block_bitvec = new int[B->n];

    for (int k = 0; k < (n)*max_n; k++)
        fullcol[k] = infinity;

    for (ib = 0; ib < B->n; ib++)
        block_bitvec[ib] = 0;

    /// block_index_map[ col in A] = col in B

    int idx_map = 0;

    block_index_map = new int[n];
    for (ib = 0; ib < B->n; ib++) {
        for (int k = 0; k < B->block_sizes[ib]; k++)
            block_index_map[idx_map + k] = ib;

        idx_map += B->block_sizes[ib];
    }

    block_start = new int[B->n];
    block_start[0] = 0;
    for (ib = 1; ib < B->n; ib++)
        block_start[ib] = block_start[ib - 1] + B->block_sizes[ib - 1];

    // Sweep sub block columns in a processor
    //

    B->c_lines->col_idcs_buf = new int[my_nnz * B->max_block_size];
    B->c_lines->col_buf = new double[my_nnz * B->max_block_size];

    std::vector<double*>  blocks(my_nbr_cols + 1, (double*) 0);

    int n_brow = B->my_nbr_cols;

    int RC = B->block_size * B->block_size;

    int row_index, column_index;
    int bj, c, n_blks = 0, count_new = 0;

    for (int bi = 0; bi < n_brow; bi++)
    {
        count_new = 0;

        B->c_lines->col_idcs[bi] = &(B->c_lines->col_idcs_buf[n_blks]);
        B->c_lines->A[bi] = &(B->c_lines->col_buf[n_blks]);
        for (int r = 0; r < B->block_size; r++)
        {
          row_index = B->block_size * bi + r;
         for (int jj = 0; jj < c_lines->len_cols[row_index]; jj++)
         {
            column_index = c_lines->col_idcs[row_index][jj];

            bj = column_index / B->block_size;
            c = column_index % B->block_size;

            if ( blocks[bj] == 0)
            {
              blocks[bj] = B->c_lines->col_buf + RC * n_blks;
              B->c_lines->col_idcs_buf[n_blks] = bj;
              n_blks++;
              count_new++;
            }


            *(blocks[bj] + B->block_size*r + c) += c_lines->A[row_index][column_index];

         }
        }

        for (int r = 0; r < B->block_size; r++)
        {
            for (int jj = 0; jj < c_lines->len_cols[B->block_size * bi + r]; jj++)
              blocks[c_lines->col_idcs[B->block_size * bi + r][jj]/B->block_size] = 0;
        }


        B->c_lines->len_cols[bi] = count_new;
        B->c_lines->len_scalar[bi] = count_new*B->block_size * B->block_size;
        B_my_nnz += count_new*B->block_size * B->block_size;

      


    }





    if (c_lines->row_idcs_buf) {
        B->c_lines->row_idcs = new int*[B->my_nbr_cols];
        jb = 0;
        for (int startj = 0; jb < max_block_columns; startj += block_sizes_local[jb], jb++) {
            if (jb < B->my_nbr_cols) {
                n1 = block_sizes_local[jb];
                count = 0; */ /*number of blocks in this block row jb*/

/*fill fullcol (actually fullrow)*/ /*
 for (int j = startj; j < startj + n1; j++) {
     for (int k = 0; k < c_lines->len_rows[j]; k++) {
         idx = c_lines->row_idcs[j][k];
         jcol = j - startj;
         fullcol[jcol * n + idx] = 1.0;

         ib = block_index_map[idx];
         if (!block_bitvec[ib]) {
             block_bitvec[ib] = 1;
             count++;
             block_start[ib] = idx;
         }
     }
 }
*/
/*Install block row structure*/     /*
     B->c_lines->row_idcs[jb] = new int[count];
     B->c_lines->len_rows[jb] = count;
     k = 0;
     next = 0;
     for (ib = 0; ib < B->n; ib++) {
         if (block_bitvec[ib]) {
             B->c_lines->row_idcs[jb][k] = ib;
             k++;
             next += m1 * n1;
             block_bitvec[ib] = 0;
         }
     }
 }
}
}
*/
/*Convert row and column data to consistent buffers*/

/*
col_buf_size = 0;
row_buf_size = 0;
A_buf_size = 0;

idx = B->my_start_idx;
for (int j = 0; j < B->my_nbr_cols; j++, idx++) {
    col_buf_size += B->c_lines->len_cols[j];
    if (B->c_lines->row_idcs)
        row_buf_size += B->c_lines->len_rows[j];
    A_buf_size += (B->block_sizes[idx] * B->c_lines->len_scalar[j]);
}

MPI_Barrier(world);
MPI_Allreduce(static_cast<void*>(&col_buf_size),
              static_cast<void*>(&max_col_buf_size), 1, MPI_INT, MPI_MAX,
world);

if (B->c_lines->row_idcs)
    MPI_Allreduce(static_cast<void*>(&row_buf_size),
                  static_cast<void*>(&max_row_buf_size), 1, MPI_INT, MPI_MAX,
world);

MPI_Allreduce(static_cast<void*>(&A_buf_size),
              static_cast<void*>(&max_A_buf_size), 1, MPI_INT, MPI_MAX, world);

B->c_lines->col_idcs_buf = new int[max_col_buf_size];
if (B->c_lines->row_idcs)
    B->c_lines->row_idcs_buf = new int[max_row_buf_size];
B->c_lines->col_buf = new double[max_A_buf_size];

ptr_adr = (B->c_lines->col_idcs_buf);
rptr_adr = (B->c_lines->row_idcs_buf);
A_adr = (B->c_lines->col_buf);
idx = B->my_start_idx;

next_ptr = 0;
next_rptr = 0;
next_Aptr = 0;

for (int j = 0; j < B->my_nbr_cols; j++, idx++) {
    num = B->c_lines->len_cols[j];
    memcpy(&(B->c_lines->col_idcs_buf[next_ptr]), B->c_lines->col_idcs[j],
           num * sizeof(int));
    next_ptr += B->c_lines->len_cols[j];
    delete[] B->c_lines->col_idcs[j];
    B->c_lines->col_idcs[j] = ptr_adr;
    ptr_adr += B->c_lines->len_cols[j];

    if (B->c_lines->row_idcs) {
        num = B->c_lines->len_rows[j];
        memcpy(&(B->c_lines->row_idcs_buf[next_rptr]),
               B->c_lines->row_idcs[j], num * sizeof(int));
        next_rptr += B->c_lines->len_rows[j];
        delete[] B->c_lines->row_idcs[j];
        B->c_lines->row_idcs[j] = rptr_adr;
        rptr_adr += B->c_lines->len_rows[j];
    }

    num = B->block_sizes[idx] * B->c_lines->len_scalar[j];
    memcpy(&(B->c_lines->col_buf[next_Aptr]), B->c_lines->A[j], num *
sizeof(double));
    next_Aptr += B->block_sizes[idx] * B->c_lines->len_scalar[j];

    delete[] B->c_lines->A[j];
    B->c_lines->A[j] = A_adr;
    A_adr += B->block_sizes[idx] * B->c_lines->len_scalar[j];
}
B->len_all_cols = new int[B->n];
MPI_Barrier(B->world);
MPI_Allgatherv(static_cast<void*>(B->c_lines->len_cols), B->my_nbr_cols,
               MPI_INT, static_cast<void*>(B->len_all_cols),
               B->all_nbr_cols, B->start_indices, MPI_INT, B->world);

B->len_all_rows = new int[B->n];
MPI_Barrier(B->world);
MPI_Allgatherv(static_cast<void*>(B->c_lines->len_rows), B->my_nbr_cols,
               MPI_INT, static_cast<void*>(B->len_all_rows),
               B->all_nbr_cols, B->start_indices, MPI_INT, B->world);

int max = 0;

for (int i = 0; i < B->my_nbr_cols; i++)
    if (B->c_lines->len_rows[i] > max)
        max = B->c_lines->len_rows[i];

for (int i = 0; i < B->my_nbr_cols; i++)
    if (B->c_lines->len_cols[i] > max)
        max = B->c_lines->len_cols[i];

B->my_nnz = B_my_nnz;

MPI_Barrier(B->world);
MPI_Allreduce(&max, &B->max_nnz, 1, MPI_INT, MPI_MAX, B->world);

B->max_nnz *= B->max_block_size * B->max_block_size;

B->remote_col_buf = new double[B->max_nnz];
memset(B->remote_col_buf, 0, B->max_nnz * sizeof(double));

B->remote_col_send = new double[B->max_nnz];
memset(B->remote_col_send, 0, B->max_nnz * sizeof(double));

B->remote_col_idcs_buf = new int[B->max_nnz];
memset(B->remote_col_idcs_buf, 0, B->max_nnz * sizeof(int));

B->remote_row_idcs_buf = new int[B->max_nnz];
memset(B->remote_row_idcs_buf, 0, B->max_nnz * sizeof(int));

delete[] fullcol;
delete[] block_bitvec;
delete[] block_start;
delete[] block_index_map;

return B;
}*/

template <typename T>
Matrix<T>* Matrix<T>::Scalar_Matrix(const int& verbose)
{
    int mnl = 0, m1, n1;
    int start_index, len, height;
    int* block_start = NULL;
    int jstart, istart, jb_global, ib_global, i_global, next, j_val;
    double val;
    double* Aval = NULL;
    Timer o_timer;

    if (verbose) {
        // Start time measurement
        o_timer = Timer();
        o_timer.Start_Timer();
    }

    Matrix<double>* S = NULL;
    S = new Matrix<double>(world);

    for (int j = 0; j < my_nbr_cols; j++) {
        mnl += block_sizes[j + my_start_idx];
    }

    S->my_nbr_cols = mnl;

    S->all_nbr_cols = new int[num_procs];

    // Filling all_nbr_cols
    MPI_Barrier(world);
    MPI_Allgather(static_cast<void*>(&mnl), 1, MPI_INT,
                  static_cast<void*>(S->all_nbr_cols), 1, MPI_INT, world);

    S->n = 0;
    for (int i = 0; i < S->num_procs; i++)
        S->n += S->all_nbr_cols[i];

    /* Only scalar matrices so far */
    S->m = S->n;

    S->start_indices = new int[S->num_procs];
    S->start_indices[0] = 0;
    for (int ipe = 1; ipe < S->num_procs; ipe++)
        S->start_indices[ipe] = S->start_indices[ipe - 1] + S->all_nbr_cols[ipe - 1];

    S->my_start_idx = S->start_indices[S->my_id];

    S->pe = new int[S->n];
    for (int ipe = 0; ipe < S->num_procs; ipe++) {
        start_index = S->start_indices[ipe];
        for (int i = 0; i < S->all_nbr_cols[ipe]; i++) {
            S->pe[start_index + i] = ipe;
        }
    }

    S->block_size = 1;
    S->max_block_size = 1;
    S->block_sizes = new int[S->n];

    for (int i = 0; i < S->n; i++)
        S->block_sizes[i] = 1;

    S->c_lines =
        new Compressed_Lines<double>(S->my_nbr_cols, 0); // No row structure

    // Reuse of array pe of the old Matrix
    block_start = new int[n];
    block_start[0] = 0;
    for (int ib = 1; ib < n; ib++)
        block_start[ib] = block_start[ib - 1] + block_sizes[ib - 1];

    /* i and j are local row and column indices into the scalar matrix.
     *      ib and jb are local row and column indices into the block matrix */
    jb_global = my_start_idx;
    jstart = 0;

    for (int jb = 0; jb < my_nbr_cols; jb++) {
        n1 = block_sizes[jb_global];
        /* Determine the scalar length of block column jb */
        height = 0;

        for (int kb = 0; kb < c_lines->len_cols[jb]; kb++) {
            ib_global = c_lines->col_idcs[jb][kb];
            height += block_sizes[ib_global];
        }

        /* Allocate Scalar columns in S associated with block column jb */
        for (int j = jstart; j < jstart + block_sizes[jb_global]; j++) {
            S->c_lines->col_idcs[j] = new int[max_nnz * max_block_size];
            S->c_lines->A[j] = new double[max_nnz * max_block_size];
            // S->c_lines->col_idcs[j] = new int[height];
            // S->c_lines->A[j] = new double[height];
            S->c_lines->len_cols[j] = 0;
        }

        /* Install values associaed with block column jb */

        next = 0;
        for (int kb = 0; kb < c_lines->len_cols[jb]; kb++) {
            Aval = &(c_lines->A[jb][next]);
            ib_global = c_lines->col_idcs[jb][kb];
            istart = block_start[ib_global];
            m1 = block_sizes[ib_global];

            for (int col = 0; col < n1; col++) {
                for (int row = 0; row < m1; row++) {
                    val = Aval[col * m1 + row];
                    if (val != 0.0) {
                        j_val = jstart + col;
                        i_global = istart + row;
                        len = S->c_lines->len_cols[j_val]++;
                        S->c_lines->col_idcs[j_val][len] = i_global;
                        S->c_lines->A[j_val][len] = val;
                    }
                }
            }
            next += m1 * n1;
        }
        jstart += block_sizes[jb_global];
        jb_global++;
    }

    /* Max nnz calculation */
    S->max_nnz = Count_NNZ();

    if (verbose) {
        // Stop time measurement
        o_timer.Stop_Timer();
        o_timer.Report_Time(world);
    }

    delete[] block_start;
    return S;
}

template <typename T>
void Matrix<T>::Scalar_Matrix_Update(Matrix<T>* S, const int& verbose)
{
    int mnl = 0, m1, n1;
    int start_index, len, height;
    int* block_start = NULL;
    int jstart, istart, jb_global, ib_global, i_global, next, j_val;
    double val;
    double* Aval = NULL;
    Timer o_timer;

    if (verbose) {
        // Start time measurement
        o_timer = Timer();
        o_timer.Start_Timer();
    }

    block_start = new int[n];
    block_start[0] = 0;
    for (int ib = 1; ib < n; ib++)
        block_start[ib] = block_start[ib - 1] + block_sizes[ib - 1];

    /* Reinitialize the length of all the scalar columns */
    for (int i = 0; i < S->my_nbr_cols; i++)
        S->c_lines->len_cols[i] = 0;

    /* i and j are local row and column indices into the scalar matrix.
     *      ib and jb are local row and column indices into the block matrix */
    jb_global = my_start_idx;
    jstart = 0;

    for (int jb = 0; jb < my_nbr_cols; jb++) {
        n1 = block_sizes[jb_global];
        /* Determine the scalar length of block column jb */
        height = 0;

        /* Install values associated with block column jb */

        next = 0;
        for (int kb = 0; kb < c_lines->len_cols[jb]; kb++) {
            Aval = &(c_lines->A[jb][next]);
            ib_global = c_lines->col_idcs[jb][kb];
            istart = block_start[ib_global];
            m1 = block_sizes[ib_global];

            for (int col = 0; col < n1; col++) {
                for (int row = 0; row < m1; row++) {
                    val = Aval[col * m1 + row];
                    if (val != 0.0) {
                        j_val = jstart + col;
                        i_global = istart + row;
                        len = S->c_lines->len_cols[j_val]++;
                        S->c_lines->col_idcs[j_val][len] = i_global;
                        S->c_lines->A[j_val][len] = val;
                    }
                }
            }
            next += m1 * n1;
        }
        jstart += block_sizes[jb_global];
        jb_global++;
    }

    /* Max nnz calculation */
    S->max_nnz = Count_NNZ();

    if (verbose) {
        // Stop time measurement
        o_timer.Stop_Timer();
        o_timer.Report_Time(world);
    }

    delete[] block_start;
}

template <typename T>
void Matrix<T>::Precomputation_Column_Square_Inverses(Matrix<T>* A)
{
    int local_buf_size = 0;
    int square_inverse_buf_size = 0;
    double* local_square_inverse_buffer =
        new double[max_block_size * max_block_size * my_nbr_cols]();
    int* len_all_square_inv = new int[num_procs];
    int* start_indices_square_inverse = new int[n];

    for (int col = 0; col < my_nbr_cols; col++) {
        Compute_Square_Inverse(A->c_lines->A[col], A->c_lines->col_idcs[col],
                               A->c_lines->len_cols[col],
                               A->block_sizes[my_start_idx + col],
                               &(local_square_inverse_buffer[local_buf_size]));

        local_buf_size +=
            A->block_sizes[my_start_idx + col] * A->block_sizes[my_start_idx + col];
    }

    // Filling len_all_square_inv
    MPI_Barrier(world);
    MPI_Allgather(static_cast<void*>(&local_buf_size), 1, MPI_INT,
                  static_cast<void*>(len_all_square_inv), 1, MPI_INT, world);

    MPI_Barrier(world);
    MPI_Allreduce(static_cast<void*>(&local_buf_size),
                  static_cast<void*>(&square_inverse_buf_size), 1, MPI_INT, MPI_SUM, world);

    double* square_inverse_buffer = new double[square_inverse_buf_size];

    start_indices_square_inverse[0] = 0;
    for (int pe = 1; pe < num_procs; pe++)
        start_indices_square_inverse[pe] =
            start_indices_square_inverse[pe - 1] + len_all_square_inv[pe - 1];

    MPI_Barrier(world);
    MPI_Allgatherv(static_cast<void*>(local_square_inverse_buffer), local_buf_size,
                   MPI_DOUBLE, static_cast<void*>(square_inverse_buffer),
                   len_all_square_inv, start_indices_square_inverse, MPI_DOUBLE, world);

    for (int col = 1; col < n; col++)
        start_indices_square_inverse[col] = start_indices_square_inverse[col - 1] +
                                            block_sizes[col - 1] * block_sizes[col - 1];

    delete[] local_square_inverse_buffer;
    local_square_inverse_buffer = NULL;
    delete[] len_all_square_inv;
    len_all_square_inv = NULL;

    Aj_sq_inv_buffer = square_inverse_buffer;
    start_indices_Aj_sq_inv = start_indices_square_inverse;
}

template <typename T>
void Matrix<T>::Compute_Square_Inverse(const double* const col_buf,
                                       const int* const col_idcs_buf,
                                       const int len,
                                       const int block_size,
                                       T* const Aj_sq_inv)
{
    int* ipiv = first_index_set;

    int lwork = -1;
    double *work = Work_qr_ptr, work_db = 0.0;

    int block_size_h, info = 0;

    int start_block = 0;
    for (int i = 0; i < len; i++) {
        block_size_h = block_sizes[col_idcs_buf[i]];
        Mult_Blocks_TN(&(col_buf[start_block]), &(col_buf[start_block]),
                       block_size, block_size, block_size_h, Aj_sq_inv);

        start_block += (block_size * block_size_h);
    }

    dgetrf_(&block_size, &block_size, Aj_sq_inv, &block_size, ipiv, &info);

    dgetri_(&block_size, Aj_sq_inv, &block_size, ipiv, &work_db, &lwork, &info);

    lwork = static_cast<int>(work_db);
    lwork = std::max(1, lwork);

    dgetri_(&block_size, Aj_sq_inv, &block_size, ipiv, work, &lwork, &info);
}

inline int comp(const void* elem1, const void* elem2)
{
    const Row_sparsify* f = (Row_sparsify*)elem1;
    const Row_sparsify* s = (Row_sparsify*)elem2;
    return fabs(f->val) > fabs(s->val) ? -1 : fabs(f->val) < fabs(s->val);
    return 0;
}

inline void kLargest(Row_sparsify arr[], int n, int k)
{
    qsort(arr, n, sizeof(arr[0]), comp);
}
