/*
    ======================================================================
    ======================================================================
    ==                                                                  ==
    ==  MSPAI:  Modified SPAI algorithm to comupte SParse Approximate   ==
    ==          Invers matrices.                                        ==
    ==                                                                  ==
    ==  Copyright (C)  2007, 2008, 2009 by                              ==
    ==                 Matous Sedlacek <sedlacek@in.tum.de>             ==
    ==                 Chair of Scientific Computing -- Informatics V   ==
    ==                 Technische Universität München                   ==
    ==                                                                  ==
    ==  This file is part of MSPAI.                                     ==
    ==                                                                  ==
    ==  MSPAI is free software: you can redistribute it and/or          ==
    ==  modify it under the terms of the GNU Lesser General Public      ==
    ==  License as published by the Free Software Foundation, either    ==
    ==  version 3 of the License, or (at your option) any later version.==
    ==                                                                  ==
    ==  MSPAI is distributed in the hope that it will be useful,        ==
    ==  but WITHOUT ANY WARRANTY; without even the implied warranty of  ==
    ==  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ==
    ==  GNU Lesser General Public License for more details.             ==
    ==                                                                  ==
    ==  You should have received a copy of the GNU Lesser General       ==
    ==  Public License along with MSPAI.                                ==
    ==  If not, see <http://www.gnu.org/licenses/>.                     ==
    ==                                                                  ==
    ======================================================================
    ======================================================================
*/


template <class T>  void
Spai_Unrestrained<T>::SPAI_Column(Matrix<T> *A,
                            Matrix<T>       *&M,
                            Matrix<T>       *B,
                            Pattern         *P,
                            Pattern         *UP,
                            Index_Set       *U_UP,
                            const int       col,
                            const double    epsilon_param,
                            const int       maxnew_param,
                            const int       max_impr_steps,
                            Hash_Table<T>   *ht,
                            const int       use_mean,
                            int             pre_k_param,
                            const int       pre_max_param,
                            unsigned int    *&bitvec,
                            unsigned int    *&reset_vec)
{
        
    int             m = 0,  // y dimension of A_hat
                    n = 0,  // x dimension of A_hat
                    unit_idx = -1,
                    nnz = 0;//number of nnz within A_Hat
                
    double          residual_norm = 1.0e+50; // appr. infinity
                            
    T               *A_Hat          = NULL,
                    *mk_Hat         = NULL,
                    *bk_Hat         = NULL,
                    *residual_vals  = NULL;
        
    Spai_Sub<T>     o_sub;
    
    Com_Server<T>   o_comm;
                                            
    Index_Set       *J = NULL, 
                    *I = NULL;

                
    // J will be filled with the
    // new J values from pattern
    // and will be updated each augmenting 
    // step.
    J = new Index_Set(A->n);    
    
    // Extract pattern from pattern matrix  
    // Create the Index Set J    
    o_comm.Get_P_Col(A, M, B, P, UP, col, J);
    
    //step is -1 because the first improvement step is 
    // only the static SPAI
    for (int step = -1; step < max_impr_steps; step++)
    {   
        // Drive on communication between pes 
        o_comm.Communicate(A, M, B, P, UP);
        
        // Get those row indices where at least one nnz
        // is available in row. Create Index Set I
        I = o_sub.Get_I_Set(J, A, M, B, P, UP, U_UP, 
                            ht, pre_k_param, pre_max_param,
                            bitvec, reset_vec);   
        J->Print_Index_Set("J");
        I->Print_Index_Set("I");

        // Create the submatrix A_Hat = A(I;J) and update the 
        // The index of the unit vector
        A_Hat = o_sub.Create_Submatrix_AHat_Block(
                                A, M, B, P, UP, U_UP,
                                J, I, m, n, ht, nnz,
                                pre_k_param, pre_max_param);
        
        printf("col : %d, jslen : %d, islen : %d\n", col, J->slen, I->slen);
    for (int k = 0; k < J->slen * I->slen; k++)
      printf("A_hat[%d] = %f\n", k, A_Hat[k]);
      
        //A_Hat = o_sub.Convert_block_AHat(A_Hat, A, J, I);
        
       
       /* 
        A_Hat = o_sub.Create_Submatrix_AHat(
                                A, M, B, P, UP, U_UP,
                                J, I, m, n, ht, nnz,
                                pre_k_param, pre_max_param);
                                */
    /*
    for (int k = 0; k < J->slen * I->slen; k++)
      printf("A_hat_after[%d] = %f\n", k, A_Hat[k]);
      */
       /* 
    for (int k = 0; k < J->len * I->len; k++)
      printf("A_hat_s[%d] = %f\n", k, A_Hat_scalar[k]);
      */
        // Create the unit vector
        // Notice that the name is the solution name already.         
        /*
        if (B)
            mk_Hat = o_sub.Create_bk_Hat(A, M, B, P, UP,
                                         I, I->len, col);
        else
        */
    //printf("len 1 : %d, len 2 : %d\n", I->len, I->slen * A->block_sizes[col]);
 //           mk_Hat = o_sub.Create_ek_Hat(I, I->len, col, unit_idx);             
        
            
          mk_Hat = o_sub.Create_ek_Hat_Block(I, A, I->slen * A->block_sizes[col], col, unit_idx);             
          
            printf("step 1 \n");
    for (int k = 0; k < I->slen * A->block_sizes[col]; k++)
      printf("ek_hat[%d] = %f\n", k, mk_Hat[k]);
      

            //printf("len mk hat in : %d\n", I->slen * A->block_sizes[col]);
            
            
     //   mk_Hat = o_sub.Convert_block_mHat(mk_Hat, A, col, I);

        /*
            printf("step 2 \n");
    for (int k = 0; k < J->slen * A->block_sizes[col]; k++)
      printf("mk_hat[%d] = %f\n", k, mk_Hat[k]);
            
    for (int k = 0; k < m*n; k++)
      printf("A_hat[%d] = %f\n", k, A_Hat[k]);

    printf("m : %d, n : %d, I->slen : %d, i->lem : %d\n", m, n, I->slen, I->len);
          */    
        // Copy the unit vector. This is used for 
        // computing the residual vector later 
        bk_Hat = o_sub.Copy_Vector(mk_Hat, I->slen * A->block_sizes[col]);
       // bk_Hat = o_sub.Copy_Vector(mk_Hat, I->len);
        
        // Computing solution m_k which is stored within
        // mk_Hat.
        /*
        printf("m : %d, n : %d\n", m, n);
        */
        Approximative_Solution( A_Hat, m, n, 
                                mk_Hat, I, A->block_sizes[col]);

        // Extract solution values
       // mk_Hat = o_sub.Get_Solution_Vals(mk_Hat, J);

        /*
            printf("step 2 \n");
    for (int k = 0; k < I->slen * A->block_sizes[col]; k++)
      printf("pre solution[%d] = %f\n", k, mk_Hat[k]);
      */
        
        //// A REMETTRE  changer la boucle dans la focntion ci dessous
        mk_Hat = o_sub.Get_Solution_Vals_Block(mk_Hat, A, col, J, I->slen);
    for (int k = 0; k < J->slen * A->block_sizes[col]; k++)
      printf("solution[%d] = %.13e\n", k, mk_Hat[k]);
                
        // Computing the residual vector
        // and the frobenius norm of it
        residual_norm = o_sub.Residual_Norm(
                                A_Hat, m, n, 
                                mk_Hat, bk_Hat, 
                                residual_vals);

        // Finishing conditions
        if ( (residual_norm <= epsilon_param)   //residual good enough
             || (step == (max_impr_steps - 1))  // Don't delete solution,
           )                                    // No augment sparsity
            break;  
        
        
        // Solution is not good enough - augmenting 
        // Finish augmenting if no new candidates found
        if (!o_sub.Augment_Sparsity(
                                A, M, B, P, I, 
                                J, UP, U_UP, col, 
                                residual_norm, 
                                residual_vals, 
                                maxnew_param, 
                                ht, use_mean,
                                pre_k_param,
                                pre_max_param,
                                bitvec, reset_vec))
            break;

        
        delete [] mk_Hat;
        delete [] A_Hat;
        delete [] bk_Hat;
        delete I;
    }
    
    //Inserting solution row into preconditioner
    o_comm.Insert_Row_Solution_Block(  A, M, B, P, UP, col, 
                                 mk_Hat, J);


    //Free heap storage last time
    if (mk_Hat)     delete [] mk_Hat;
    if (bk_Hat)     delete [] bk_Hat;
    if (A_Hat)      delete [] A_Hat;
    delete I;
    delete J;
}


template<class T>   void
Spai_Unrestrained<T>::Approximative_Solution( T*      A_Hat_orig, 
                                              int&    m, 
                                              int&    n, 
                                              T*&     mk_Hat,
                                              const   Index_Set* I,
                                              const int block_size_col)
{
    
    int         lda      = 0,
                k        = 0,
                info     = 0,
                lwork    = 0,
                one      = block_size_col;
                            
    T           *A_Hat   = NULL,
                *tau     = NULL,
                *work_qr = NULL,
                *work_qt = NULL;
        
    Spai_Sub<T> o_sub;
        
    // Lapack input parameters 
    const char  *SIDE    = "L", 
                *UPLO    = "U", 
                *TRANS   = "",
                *NCHAR   = "N";
                
                
    // Copy A_Hat because lapack routines change input
    // and the original A_Hat is used later as well
    A_Hat = o_sub.Copy_Vector(A_Hat_orig, m * n);
    
        
    //Preprocessing step:
    //Get the optimal lwork value for fastest 
    //QR decomposition. See lapack documentation for
    //details.
    lwork = o_sub.Opt_lwork_QRDecomp(A_Hat, m, n);
    
    
    // Init lapack values necessary for lapack routines
    o_sub.Init_Lapack_Vals( m, n, k,
                            lda, lwork,
                            &work_qr,
                            &tau);
        
 
    //QR decomposition -> Computing :   A_hat = QR
    o_sub.QR_Decomposition( m, n, A_Hat,  
                            lda, tau, work_qr,
                            lwork, info);


    //Preprocessing step:
    //Get the optimal lwork value for fastest 
    //QT * vector multiplication. See lapack documentation for
    //details.
    lwork = o_sub.Opt_lwork_QTApply(
                            SIDE, m, n, 
                            k, one, lda,
                            A_Hat, tau, mk_Hat);
    
    
    // Set new work array -> faster than realloc work_qr
    work_qt = new T[lwork];
    memset(work_qt, 0, lwork * sizeof(T));  
    

    // Computing :   Q^T * e_k_hat  
    o_sub.QT_Apply(         SIDE, TRANS, m,
                            one, k, A_Hat,
                            lda, tau, mk_Hat,
                            work_qt, lwork, info);
    
    
    // Getting the quadratic contingent of 
    // the matrix A_hat for both cases:   
    // m x n and n x m
    o_sub.Ectract_Quadratic_Content(A_Hat, m, n);
        
        
    // Solving the triangular system:
    // Computing :   R^-1 * (Q^T * e_k_hat)
    o_sub.Solve_Tr_System_Block(  UPLO, NCHAR, n,
                            one, I->slen, A_Hat, mk_Hat,
                            info);
    
    delete [] work_qr;
    delete [] work_qt;
    delete [] tau;
    delete [] A_Hat;

}
